<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Linux on mahaoliang.tech</title>
        <link>https://mahaoliang.tech/tags/linux/</link>
        <description>Recent content in Linux on mahaoliang.tech</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Sun, 31 Aug 2025 21:04:45 +0800</lastBuildDate><atom:link href="https://mahaoliang.tech/tags/linux/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>深入解析 .bash_profile 与 .bashrc</title>
        <link>https://mahaoliang.tech/p/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-.bash_profile-%E4%B8%8E-.bashrc/</link>
        <pubDate>Sun, 31 Aug 2025 21:04:45 +0800</pubDate>
        
        <guid>https://mahaoliang.tech/p/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-.bash_profile-%E4%B8%8E-.bashrc/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202508312117799.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;shell&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当你刚刚安装好一个新的命令行程序，通常需要手动将它的 &lt;code&gt;bin&lt;/code&gt; 目录添加到系统的 &lt;code&gt;PATH&lt;/code&gt; 环境变量中。这样，你才能在任何路径下直接调用它的命令。&lt;/p&gt;
&lt;p&gt;此时，一个很实际的问题摆在了面前：应该把 &lt;code&gt;export PATH=&amp;quot;&amp;lt;新增路径&amp;gt;:$PATH&amp;quot;&lt;/code&gt; 这行配置代码加到哪个文件里？&lt;/p&gt;
&lt;p&gt;你可能会想到 &lt;code&gt;~/.bashrc&lt;/code&gt;，或者 &lt;code&gt;~/.profile&lt;/code&gt;，也可能听说过 &lt;code&gt;~/.bash_login&lt;/code&gt; 和 &lt;code&gt;~/.bash_profile&lt;/code&gt;。这些文件似乎都可以在 Shell 启动时加载配置，那把 &lt;code&gt;PATH&lt;/code&gt; 的设置放在哪里，是不是都一样呢？&lt;/p&gt;
&lt;p&gt;也许你觉得随便选一个文件把配置加在末尾，都能正常工作。但实际上，这些文件的加载时机和应用场景有着本质的区别。错误地放置配置，可能会导致 &lt;code&gt;PATH&lt;/code&gt; 变量被反复添加重复的路径，变得越来越长；或者更严重地，可能导致一些自动化脚本（如 &lt;code&gt;scp&lt;/code&gt; 文件传输）在远程执行时意外失败。&lt;/p&gt;
&lt;p&gt;本文的目的，就是梳理清楚这些 Shell 启动配置文件的差异，让你彻底搞懂它们的工作原理。读完之后，你将不再似懂非懂，而是能准确地判断出什么配置应该放在哪里。&lt;/p&gt;
&lt;h2 id=&#34;理解-bash-的运行模式&#34;&gt;理解 Bash 的运行模式&lt;/h2&gt;
&lt;p&gt;要搞清楚 Shell 配置文件如何加载，首先必须理解 Bash 自身是如何启动和运行的。一个正在运行的 Bash 实例，其状态可以由两个独立的维度来描述：&lt;strong&gt;“交互式”还是“非交互式”&lt;/strong&gt;，以及**“登录”还是“非登录”**。&lt;/p&gt;
&lt;p&gt;这四个基本概念的组合，决定了 Bash 会去加载哪个配置文件。&lt;/p&gt;
&lt;h3 id=&#34;交互模式-interactive-vs-非交互模式-non-interactive&#34;&gt;交互模式 (Interactive) vs. 非交互模式 (Non-interactive)&lt;/h3&gt;
&lt;p&gt;这个维度的核心区别在于，Shell 是用来和人“对话”，还是用来自动执行任务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;交互模式 (Interactive Mode)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这种模式下，Shell 会提供一个命令提示符（比如 &lt;code&gt;$&lt;/code&gt;），等待用户从键盘输入命令。用户输入命令并按回车后，Shell 执行它，输出结果，然后再次显示提示符，等待下一个命令。顾名思义，这是一个与用户持续“交互”的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何启动交互模式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在图形界面下打开一个终端程序（Terminal, iTerm, Konsole 等）。&lt;/li&gt;
&lt;li&gt;在已有的终端中，直接输入 &lt;code&gt;bash&lt;/code&gt; 并回车。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;ssh user@host&lt;/code&gt; 成功连接到远程主机后，获得的那个 Shell。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;非交互模式 (Non-interactive Mode)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这种模式下，Shell 不会提供命令提示符，也不等待用户输入。它的任务是执行一个预先定义好的命令集，执行完毕后就自动退出。它的输入源通常是一个文件（脚本）或一个字符串，而不是键盘。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何启动非交互模式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行一个 Shell 脚本，例如：&lt;code&gt;bash my_script.sh&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;-c&lt;/code&gt; 选项来执行一个字符串命令，例如：&lt;code&gt;bash -c &amp;quot;echo Hello, World&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 Cron 定时任务中执行的脚本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;登录-shell-login-vs-非登录-shell-non-login&#34;&gt;登录 Shell (Login) vs. 非登录 Shell (Non-login)&lt;/h3&gt;
&lt;p&gt;这个维度的区别在于，这个 Shell 实例是不是用户登录会话（session）的第一个进程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;登录 Shell (Login Shell)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个登录 Shell，代表你作为某个用户“登录”到了系统。这个过程通常需要身份验证（比如输入密码或使用 SSH 密钥）。这个 Shell 是你整个会话的起点，之后在该会话中启动的所有其他进程都是它的子进程或后代进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何启动登录 Shell：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在物理控制台（没有图形界面的那种）输入用户名和密码登录系统。&lt;/li&gt;
&lt;li&gt;通过 SSH 成功连接到远程服务器：&lt;code&gt;ssh user@host&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;bash --login&lt;/code&gt; 或 &lt;code&gt;bash -l&lt;/code&gt; 命令手动启动。&lt;/li&gt;
&lt;li&gt;在某些操作系统（如默认配置的 macOS）中，打开终端应用启动的第一个 Shell 就是登录 Shell。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;非登录 Shell (Non-login Shell)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何在已经存在的登录会话中启动的 Shell，都是非登录 Shell。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何启动非登录 Shell：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在图形界面的终端里，再打开一个新的标签页或窗口（在大多数 Linux 发行版中是这样）。&lt;/li&gt;
&lt;li&gt;在一个已有的 Shell 中，直接输入 &lt;code&gt;bash&lt;/code&gt; 来启动一个新的子 Shell。&lt;/li&gt;
&lt;li&gt;执行一个 Shell 脚本（如 &lt;code&gt;bash my_script.sh&lt;/code&gt;），为这个脚本创建的 Shell 实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四种组合与常见场景&#34;&gt;四种组合与常见场景&lt;/h3&gt;
&lt;p&gt;将以上两个维度组合起来，我们就得到了四种 Shell 的运行状态。不同的启动方式会对应不同的状态组合，而每种组合会加载不同的配置文件。&lt;/p&gt;
&lt;p&gt;下表总结了这四种组合的常见场景，以及它们默认会加载的用户配置文件（&lt;code&gt;~&lt;/code&gt; 目录下的文件）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;模式组合&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;常见示例&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;加载的用户配置文件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;交互式登录 Shell&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;需要身份认证，启动后提供一个可反复输入命令的提示符，是整个用户会话的起点。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;• &lt;code&gt;ssh user@host&lt;/code&gt;&lt;!-- raw HTML omitted --&gt;• 在物理控制台输入密码登录&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;~/.bash_profile&lt;/code&gt;&lt;!-- raw HTML omitted --&gt;(若无，则找 &lt;code&gt;~/.bash_login&lt;/code&gt;)&lt;!-- raw HTML omitted --&gt;(若再无，则找 &lt;code&gt;~/.profile&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;交互式非登录 Shell&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在一个已经登录的会话中，启动一个新的、提供命令提示符的 Shell 实例。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;• 在 Ubuntu 桌面环境中打开一个新终端&lt;!-- raw HTML omitted --&gt;• 在已有 Shell 中执行 &lt;code&gt;bash&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;~/.bashrc&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;非交互式登录 Shell&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;需要身份认证，但目的是为了执行一个特定的命令或脚本，执行完毕后立即退出，不提供交互提示符。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;• &lt;code&gt;ssh user@host &#39;ls -l&#39;&lt;/code&gt;&lt;!-- raw HTML omitted --&gt;• &lt;code&gt;bash --login my_script.sh&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;与“交互式登录 Shell”相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;非交互式非登录 Shell&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;纯粹的脚本执行器，在已登录的会话中启动，无需额外认证，也无须与用户交互。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;• &lt;code&gt;bash script.sh&lt;/code&gt;&lt;!-- raw HTML omitted --&gt;• Cron 定时任务&lt;!-- raw HTML omitted --&gt;• &lt;code&gt;scp&lt;/code&gt; 命令在远程主机上的执行端&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;(默认无)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;理解了这个表格，你就掌握了解读 Shell 配置文件的钥匙。接下来，我们将深入探讨每个配置文件具体的内容和它们之间的协作关系。&lt;/p&gt;
&lt;h2 id=&#34;各配置文件的加载时机&#34;&gt;各配置文件的加载时机&lt;/h2&gt;
&lt;p&gt;理解了 Shell 的四种运行模式后，我们就可以准确地“对号入座”，看看 Bash 在不同模式下会选择加载哪个配置文件了。&lt;/p&gt;
&lt;h3 id=&#34;登录-shell-的加载顺序三选一的规则&#34;&gt;登录 Shell 的加载顺序：三选一的规则&lt;/h3&gt;
&lt;p&gt;当 Bash 作为 &lt;strong&gt;登录 Shell&lt;/strong&gt; 启动时，它会遵循一个非常明确的、一次性的查找规则来加载配置文件。它会按照以下顺序检查用户主目录（&lt;code&gt;~&lt;/code&gt;）下的文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;~/.bash_profile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.bash_login&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.profile&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;核心原则是：Bash 只会加载它找到的第一个文件，然后立即停止搜索。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个例子，如果你的主目录下同时存在 &lt;code&gt;~/.bash_profile&lt;/code&gt; 和 &lt;code&gt;~/.profile&lt;/code&gt; 这两个文件，那么在登录时，&lt;strong&gt;只有 &lt;code&gt;~/.bash_profile&lt;/code&gt; 会被执行&lt;/strong&gt;，&lt;code&gt;~/.profile&lt;/code&gt; 将被完全忽略。&lt;/p&gt;
&lt;h3 id=&#34;这三个文件有什么区别为什么我的-ubuntu-上只有-profile&#34;&gt;这三个文件有什么区别？为什么我的 Ubuntu 上只有 &lt;code&gt;.profile&lt;/code&gt;？&lt;/h3&gt;
&lt;p&gt;这三个文件在功能上都是为登录 Shell 服务的，它们的区别主要在于历史和兼容性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;~/.bash_profile&lt;/code&gt;&lt;/strong&gt;：这是 Bash 官方首选的、&lt;strong&gt;专用于 Bash&lt;/strong&gt; 的登录配置文件。如果你的工作环境确定只使用 Bash，并且想在配置中使用一些 Bash 特有的高级语法，那么创建和使用这个文件是“最标准”的做法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;~/.bash_login&lt;/code&gt;&lt;/strong&gt;：这是一个历史遗留的备用选项，从 C Shell (&lt;code&gt;csh&lt;/code&gt;) 的 &lt;code&gt;.login&lt;/code&gt; 文件借鉴而来。如今已经非常少见，在新的配置中可以忽略它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;~/.profile&lt;/code&gt;&lt;/strong&gt;：这是&lt;strong&gt;兼容性最好&lt;/strong&gt;的选项。它源自更古老的 Bourne Shell (&lt;code&gt;sh&lt;/code&gt;)，因此，几乎所有主流的 Shell（包括 &lt;code&gt;sh&lt;/code&gt;, &lt;code&gt;dash&lt;/code&gt;, &lt;code&gt;ksh&lt;/code&gt;, 以及 &lt;code&gt;bash&lt;/code&gt;）都能识别并加载它。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在来回答那个关键问题：“为什么我的 Ubuntu 系统默认只有一个 &lt;code&gt;~/.profile&lt;/code&gt; 文件？”&lt;/p&gt;
&lt;p&gt;答案主要有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为了系统兼容性&lt;/strong&gt;：Ubuntu 和其他 Debian 系的 Linux，其系统脚本（&lt;code&gt;/bin/sh&lt;/code&gt;）默认是由 &lt;code&gt;dash&lt;/code&gt; 这个轻量级 Shell 来解释执行的，而不是 &lt;code&gt;bash&lt;/code&gt;。&lt;code&gt;dash&lt;/code&gt; 为了追求速度和简洁，并不认识 &lt;code&gt;~/.bash_profile&lt;/code&gt;。为了保证系统在执行各类脚本时都能加载到一个基础的环境配置（比如系统默认的 &lt;code&gt;PATH&lt;/code&gt;），使用所有兼容 Shell 都认识的 &lt;code&gt;~/.profile&lt;/code&gt; 是最稳妥、最可靠的选择。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为了用户简洁性&lt;/strong&gt;：对于绝大多数用户，提供一个 &lt;code&gt;.profile&lt;/code&gt; 用于登录，一个 &lt;code&gt;.bashrc&lt;/code&gt; 用于交互，分工明确，已经完全足够。这避免了让用户在三个功能相似的登录文件中纠结，简化了配置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;bashrc-的使命为交互式非登录-shell-服务&#34;&gt;&lt;code&gt;.bashrc&lt;/code&gt; 的使命：为交互式非登录 Shell 服务&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;.bashrc&lt;/code&gt; 的加载规则非常简单和专一：&lt;strong&gt;每当一个交互式的、非登录的 Shell 启动时，它就会被加载。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最常见的场景就是：在你登录系统后，在图形界面中打开一个新的终端窗口或标签页。每打开一次，&lt;code&gt;.bashrc&lt;/code&gt; 就会被执行一次。&lt;/p&gt;
&lt;h3 id=&#34;profile-是如何与-bashrc-协作的&#34;&gt;&lt;code&gt;.profile&lt;/code&gt; 是如何与 &lt;code&gt;.bashrc&lt;/code&gt; 协作的&lt;/h3&gt;
&lt;p&gt;现在，一个逻辑上的问题出现了：登录时只加载 &lt;code&gt;.profile&lt;/code&gt;，而打开新终端只加载 &lt;code&gt;.bashrc&lt;/code&gt;。那我们定义在 &lt;code&gt;.bashrc&lt;/code&gt; 里的别名（alias），为什么在登录 Shell 里也能用呢？&lt;/p&gt;
&lt;p&gt;答案就藏在 Ubuntu 默认的 &lt;code&gt;~/.profile&lt;/code&gt; 文件里。这个文件扮演了一个至关重要的“桥梁”角色。打开你的 &lt;code&gt;~/.profile&lt;/code&gt;，你会看到类似下面这样的代码片段：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# if running bash&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; -n &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BASH_VERSION&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# include .bashrc if it exists&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; -f &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;/.bashrc&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	. &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;/.bashrc&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这段代码的意思是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，检查当前运行的 Shell 是不是 Bash (&lt;code&gt;[ -n &amp;quot;$BASH_VERSION&amp;quot; ]&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;如果是 Bash，就再去检查 &lt;code&gt;~/.bashrc&lt;/code&gt; 文件是否存在。&lt;/li&gt;
&lt;li&gt;如果存在，就通过 &lt;code&gt;.&lt;/code&gt; 命令（&lt;code&gt;source&lt;/code&gt; 的简写形式）来执行 &lt;code&gt;.bashrc&lt;/code&gt; 文件的内容。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这段代码，一个优雅的协作流程就形成了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;当你登录时 (Login Shell)&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shell 首先执行 &lt;code&gt;~/.profile&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.profile&lt;/code&gt; 设置好 &lt;code&gt;PATH&lt;/code&gt; 等环境变量。&lt;/li&gt;
&lt;li&gt;然后，它内部的代码会主动调用并执行 &lt;code&gt;~/.bashrc&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bashrc&lt;/code&gt; 里的别名、函数、提示符等交互式配置也随之生效。&lt;/li&gt;
&lt;li&gt;最终，你的登录 Shell 拥有了完整的环境。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;当你打开新终端时 (Non-login Shell)&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个 Shell 只会执行 &lt;code&gt;~/.bashrc&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;别名、函数等交互式配置被设置好。&lt;/li&gt;
&lt;li&gt;而 &lt;code&gt;PATH&lt;/code&gt; 这类环境变量，则直接从创建它的父进程（你的桌面环境或登录 Shell）那里继承而来，无需重复设置。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这种“登录文件主动包含交互文件”的设计，系统实现了一套既高效又一致的 Shell 环境配置方案。&lt;/p&gt;
&lt;h2 id=&#34;什么配置应该放在哪里&#34;&gt;什么配置应该放在哪里？&lt;/h2&gt;
&lt;p&gt;现在我们清楚了不同文件的加载时机，下一个问题自然就是：具体哪种配置，应该放在哪个文件里？&lt;/p&gt;
&lt;p&gt;这里的核心判断原则是：&lt;strong&gt;这个配置是否需要被后续所有程序继承？以及，这个配置操作重复执行多次，会不会产生副作用？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;原则一只需执行一次的配置---profile-或-bash_profile&#34;&gt;原则一：只需执行一次的配置 -&amp;gt; &lt;code&gt;.profile&lt;/code&gt; 或 &lt;code&gt;.bash_profile&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这类配置的特点是，它们在登录时设置一次后，就会被当前会话中启动的所有子进程（包括之后打开的每一个新终端）所继承。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应该放在这里的内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;环境变量的设置&lt;/strong&gt;：这是最主要的应用。比如 &lt;code&gt;PATH&lt;/code&gt;、&lt;code&gt;JAVA_HOME&lt;/code&gt;、&lt;code&gt;GOPATH&lt;/code&gt;、&lt;code&gt;ANDROID_HOME&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启动会话级的后台服务&lt;/strong&gt;：比如启动一个 &lt;code&gt;ssh-agent&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为什么放在这里：&lt;/strong&gt;
因为环境变量会被子进程继承，所以我们没有必要、也不应该在每次打开新终端时都去重复设置它们。在登录时设置一次，就“一劳永逸”了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;“幂等” (Idempotent) 的概念：&lt;/strong&gt;
在编程中，“幂等”指的是一个操作，无论执行一次还是执行 N 次，产生的结果都是完全相同的。
现在，让我们审视一下修改 &lt;code&gt;PATH&lt;/code&gt; 变量的这行命令：
&lt;code&gt;export PATH=&amp;quot;$PATH:/new/path&amp;quot;&lt;/code&gt;
这个操作是幂等的吗？&lt;strong&gt;不是&lt;/strong&gt;。每执行一次，它都会在现有的 &lt;code&gt;$PATH&lt;/code&gt; 字符串后面追加一次 &lt;code&gt;:/new/path&lt;/code&gt;。如果重复执行，&lt;code&gt;PATH&lt;/code&gt; 变量会变得冗长、混乱且包含大量重复条目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：对于非幂等且需要被继承的配置，必须将它放在一个只执行一次的文件里，&lt;code&gt;.profile&lt;/code&gt; (或 &lt;code&gt;.bash_profile&lt;/code&gt;) 正是为此而生。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;原则二每次打开新终端都需要的功能---bashrc&#34;&gt;原则二：每次打开新终端都需要的功能 -&amp;gt; &lt;code&gt;.bashrc&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;这类配置的特点是，它们不会被子进程继承，只在当前 Shell 进程内有效。因此，如果希望每个新打开的终端都具备这些功能，就必须在每次启动时都重新加载它们。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应该放在这里的内容：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;命令别名 (alias)&lt;/strong&gt;：例如 &lt;code&gt;alias ll=&#39;ls -alF&#39;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shell 函数 (function)&lt;/strong&gt;：你自己编写的各种便捷脚本函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自定义的命令提示符 (PS1)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shell 选项的设置&lt;/strong&gt;：通过 &lt;code&gt;set&lt;/code&gt; 或 &lt;code&gt;shopt&lt;/code&gt; 命令开启或关闭的 Shell 行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为什么放在这里：&lt;/strong&gt;
因为别名、函数等配置不会被继承。你在一个终端里设置的别名，在另一个新打开的终端里是无效的。所以，必须把它们放在每次打开新终端都会执行的 &lt;code&gt;.bashrc&lt;/code&gt; 文件里。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实验一个反面教材&#34;&gt;实验：一个反面教材&lt;/h3&gt;
&lt;p&gt;为了直观地感受错误配置带来的问题，我们来做一个简单的实验，故意将非幂等的 &lt;code&gt;PATH&lt;/code&gt; 设置放进 &lt;code&gt;.bashrc&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;场景布置&lt;/strong&gt;
打开你的 &lt;code&gt;~/.bashrc&lt;/code&gt; 文件，在文件末尾添加下面这行代码并保存：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$PATH&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;:/my_test_path&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开始操作&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，关闭所有终端，然后打开一个&lt;strong&gt;新&lt;/strong&gt;的终端。这会加载一次 &lt;code&gt;.bashrc&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在这个新终端里，输入 &lt;code&gt;bash&lt;/code&gt; 并回车。这会启动一个子 Shell，它会再次加载 &lt;code&gt;.bashrc&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在子 Shell 中，再输入一次 &lt;code&gt;bash&lt;/code&gt; 并回车，启动孙 Shell，这将第三次加载 &lt;code&gt;.bashrc&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;现在，我们来检查一下 &lt;code&gt;PATH&lt;/code&gt; 变量。输入以下命令：
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$PATH&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;观察结果&lt;/strong&gt;：
你会看到类似下面这样的输出，&lt;code&gt;/my_test_path&lt;/code&gt; 在末尾重复出现了三次：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/my_test_path:/my_test_path:/my_test_path
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实验证明&lt;/strong&gt;：
这个结果清晰地证明了，将非幂等操作放在 &lt;code&gt;.bashrc&lt;/code&gt; 中是错误的做法。每启动一个交互式 Shell，它都会不加判断地执行一次，导致配置的累积和环境的污染。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;完成实验后，记得删除你添加到 &lt;code&gt;.bashrc&lt;/code&gt; 的那一行测试代码。&lt;/p&gt;
&lt;h2 id=&#34;ubuntu-默认配置分析&#34;&gt;Ubuntu 默认配置分析&lt;/h2&gt;
&lt;p&gt;本章我们来剖析 Ubuntu 默认 &lt;code&gt;.bashrc&lt;/code&gt; 文件中的一个关键设计，并解释它为何能避免一些严重的潜在问题。&lt;/p&gt;
&lt;h3 id=&#34;bashrc-的保护判断&#34;&gt;&lt;code&gt;.bashrc&lt;/code&gt; 的“保护判断”&lt;/h3&gt;
&lt;p&gt;如果你打开 Ubuntu 默认的 &lt;code&gt;~/.bashrc&lt;/code&gt; 文件，很可能会在文件开头看到下面这段代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# If not running interactively, don&amp;#39;t do anything&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$-&lt;/span&gt; in
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    *i*&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      *&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;esac&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这段代码是什么意思？它是一个“保护判断”，作用是确保 &lt;code&gt;.bashrc&lt;/code&gt; 文件中后续的所有配置，只在交互模式下执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;case $- in ... esac&lt;/code&gt;：这是一个条件判断语句，它检查 &lt;code&gt;$-&lt;/code&gt; 这个特殊变量的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$-&lt;/code&gt;：这个变量包含当前 Shell 的一系列选项标志。如果它包含字母 &lt;code&gt;i&lt;/code&gt;，就代表当前是一个&lt;strong&gt;交互式 (interactive)&lt;/strong&gt; Shell。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*i*) ;;&lt;/code&gt;：这是一个模式匹配。如果 &lt;code&gt;$-&lt;/code&gt; 的值包含 &lt;code&gt;i&lt;/code&gt;，则匹配成功。后面的 &lt;code&gt;;;&lt;/code&gt; 表示“匹配成功后，什么也不做”，然后继续执行 &lt;code&gt;.bashrc&lt;/code&gt; 文件的后续代码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*) return;;&lt;/code&gt;：这是一个“捕获所有其他情况”的模式。如果 &lt;code&gt;$-&lt;/code&gt; 的值&lt;strong&gt;不&lt;/strong&gt;包含 &lt;code&gt;i&lt;/code&gt;（即非交互模式），则执行 &lt;code&gt;return&lt;/code&gt; 命令。在一个被 &lt;code&gt;source&lt;/code&gt; 的脚本中，&lt;code&gt;return&lt;/code&gt; 会立即终止该脚本的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说，这段代码的逻辑就是：&lt;strong&gt;“是交互模式吗？是就继续。不是？立刻退出，别往下读了。”&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;当-scp-遭遇热情的-bashrc&#34;&gt;当 &lt;code&gt;scp&lt;/code&gt; 遭遇“热情”的 &lt;code&gt;.bashrc&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;为什么要费这么大功夫做一个检查？非交互模式下执行一下别名、函数，似乎也无伤大雅？让我们来看一个真实且常见的失败案例，它能完美地解释这个保护判断的重要性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景设定：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;远程服务器配置&lt;/strong&gt;：一位系统管理员为了登录服务器时能看到一句欢迎语，就在服务器的 &lt;code&gt;~/.bashrc&lt;/code&gt; 文件里加了一行 &lt;code&gt;echo &amp;quot;Welcome back to the server!&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移除保护&lt;/strong&gt;：为了模拟问题，我们假设他不小心删除了 &lt;code&gt;.bashrc&lt;/code&gt; 文件开头的那段保护判断代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地操作&lt;/strong&gt;：现在，他在自己的本地电脑上，尝试用 &lt;code&gt;scp&lt;/code&gt; 命令向这台配置错误的服务器上传一个文件：
&lt;code&gt;scp my_local_file.txt user@remote_server:/home/user/&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;灾难是如何发生的：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;scp&lt;/code&gt; 的工作原理&lt;/strong&gt;：&lt;code&gt;scp&lt;/code&gt; 命令在后台通过 SSH 登录到远程服务器。它并不会启动一个我们平时用的那种交互式 Shell，而是请求服务器启动一个&lt;strong&gt;非交互式&lt;/strong&gt;的 Shell 来专门处理文件传输。这是一个程序与程序之间的对话，它们之间通过一套严格的 &lt;code&gt;scp&lt;/code&gt; 协议来通信。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;“热情”的干扰&lt;/strong&gt;：因为服务器上的 &lt;code&gt;.bashrc&lt;/code&gt; 没有了保护判断，这个为 &lt;code&gt;scp&lt;/code&gt; 启动的非交互式 Shell，也会去执行 &lt;code&gt;.bashrc&lt;/code&gt; 里的所有内容。于是，&lt;code&gt;echo &amp;quot;Welcome back...&amp;quot;&lt;/code&gt; 这条命令被执行了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;污染通信协议&lt;/strong&gt;：这句“Welcome back&amp;hellip;”的问候语，作为一段普通的文本，被发送回了本地的 &lt;code&gt;scp&lt;/code&gt; 客户端。但此时，&lt;code&gt;scp&lt;/code&gt; 客户端正在等待的是符合协议规范的确认信号，而不是一段人类阅读的欢迎词。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命令失败&lt;/strong&gt;：这段意料之外的文本“污染”了 &lt;code&gt;scp&lt;/code&gt; 协议的通信流。&lt;code&gt;scp&lt;/code&gt; 客户端无法解析它，认为通信出错，最终导致命令失败，并可能抛出一个令人费解的错误，如“protocol error”或“lost connection”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个例子清晰地表明，&lt;code&gt;.bashrc&lt;/code&gt; 开头的保护判断是一个至关重要的安全措施。它确保了那些为人类交互而设计的配置，不会干扰到那些需要在纯净、可预测的环境下工作的自动化工具（如 &lt;code&gt;scp&lt;/code&gt;、&lt;code&gt;rsync&lt;/code&gt;、&lt;code&gt;git&lt;/code&gt; 等）。&lt;/p&gt;
&lt;h3 id=&#34;非交互模式为何无法加载-bashrc&#34;&gt;非交互模式为何无法加载 &lt;code&gt;.bashrc&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;我们可以通过一个简单的脚本实验，亲眼验证这个保护判断是如何工作的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建脚本 &lt;code&gt;test.sh&lt;/code&gt;&lt;/strong&gt;:
在你的主目录下创建一个名为 &lt;code&gt;test.sh&lt;/code&gt; 的文件，内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;UNIQUE_ID&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$$&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;VAR_VALUE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;new_env_value_&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;UNIQUE_ID&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 为了保证实验干净，先确保 .bashrc 中没有我们要测试的变量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sed -i &lt;span class=&#34;s1&#34;&gt;&amp;#39;/export NEW_ENV/d&amp;#39;&lt;/span&gt; &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;HOME&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;/.bashrc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;--- 实验开始 (进程 ID: &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;UNIQUE_ID&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;) ---&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;1. 尝试向 .bashrc 文件末尾添加一个环境变量...&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;export NEW_ENV=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;VAR_VALUE&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &amp;gt;&amp;gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;HOME&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;/.bashrc&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2. 尝试在当前脚本 (非交互) 中 source .bashrc 来让它立即生效...&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;HOME&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;/.bashrc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;3. 读取 NEW_ENV 的值：[&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$NEW_ENV&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;]&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 清理工作：再次移除我们添加的行&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sed -i &lt;span class=&#34;s1&#34;&gt;&amp;#39;/export NEW_ENV/d&amp;#39;&lt;/span&gt; &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;HOME&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;/.bashrc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;--- 实验结束 ---&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行与结果&lt;/strong&gt;：
给脚本执行权限 &lt;code&gt;chmod +x test.sh&lt;/code&gt;，然后运行它 &lt;code&gt;./test.sh&lt;/code&gt;。你会看到如下输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--- 实验开始 &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;进程 ID: 436292&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; ---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1. 尝试向 .bashrc 文件末尾添加一个环境变量...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2. 尝试在当前脚本 &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;非交互&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; 中 &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; .bashrc 来让它立即生效...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3. 读取 NEW_ENV 的值：&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--- 实验结束 ---
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结果分析&lt;/strong&gt;：
实验结果表明，&lt;code&gt;$NEW_ENV&lt;/code&gt; 的值是空的！尽管我们确实把 &lt;code&gt;export&lt;/code&gt; 语句添加到了 &lt;code&gt;.bashrc&lt;/code&gt; 文件中，并且执行了 &lt;code&gt;source&lt;/code&gt; 命令，但这个变量并没有被设置到当前脚本的环境中。&lt;/p&gt;
&lt;p&gt;原因正在于 &lt;code&gt;.bashrc&lt;/code&gt; 开头的那段保护判断。当 &lt;code&gt;test.sh&lt;/code&gt; 这个非交互式脚本执行到 &lt;code&gt;source ${HOME}/.bashrc&lt;/code&gt; 时，&lt;code&gt;.bashrc&lt;/code&gt; 内部的 &lt;code&gt;case&lt;/code&gt; 语句检测到当前并非交互模式，于是立即执行 &lt;code&gt;return&lt;/code&gt;，终止了自身的执行。因此，我们刚刚添加进去的 &lt;code&gt;export NEW_ENV=...&lt;/code&gt; 那一行，以及文件中的其他所有配置，都根本没有机会被执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总结回顾&#34;&gt;总结回顾&lt;/h2&gt;
&lt;p&gt;让我们再次梳理一下核心知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Shell 的四种模式&lt;/strong&gt;：Bash 的运行状态由“交互式/非交互式”和“登录/非登录”这两个维度共同决定。不同的启动方式（如 &lt;code&gt;ssh&lt;/code&gt; 登录、打开终端、执行脚本）会对应不同的模式组合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;配置文件的分工&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;~/.bash_profile&lt;/code&gt; (或兼容性更强的 &lt;code&gt;~/.profile&lt;/code&gt;)&lt;/strong&gt;：专为 &lt;strong&gt;登录 Shell&lt;/strong&gt; 服务。它在用户会话开始时仅执行一次，是设置环境变量（如 &lt;code&gt;PATH&lt;/code&gt;）和执行一次性初始化任务的最佳位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;~/.bashrc&lt;/code&gt;&lt;/strong&gt;：专为 &lt;strong&gt;交互式非登录 Shell&lt;/strong&gt; 服务。每次打开新的终端窗口时，它都会被执行，因此是定义别名、函数、自定义提示符等增强交互体验功能的理想场所。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;协作的关键&lt;/strong&gt;：在像 Ubuntu 这样的主流发行版中，&lt;code&gt;~/.profile&lt;/code&gt; 文件会主动 &lt;code&gt;source&lt;/code&gt;（加载）&lt;code&gt;~/.bashrc&lt;/code&gt; 文件。这一“桥梁”设计，确保了登录 Shell 和后续打开的非登录 Shell 拥有一致的交互环境。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;环境的纯净性&lt;/strong&gt;：&lt;code&gt;.bashrc&lt;/code&gt; 文件开头的&lt;strong&gt;非交互模式保护判断&lt;/strong&gt;至关重要。它能防止为人类交互设计的配置（如 &lt;code&gt;echo&lt;/code&gt; 输出、别名等）干扰到需要在纯净环境下运行的自动化工具（如 &lt;code&gt;scp&lt;/code&gt;, &lt;code&gt;rsync&lt;/code&gt; 等），避免难以排查的协议错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>我在开源之夏为 openEuler 提交的第一个 PR 被合并了！</title>
        <link>https://mahaoliang.tech/p/%E6%88%91%E5%9C%A8%E5%BC%80%E6%BA%90%E4%B9%8B%E5%A4%8F%E4%B8%BA-openeuler-%E6%8F%90%E4%BA%A4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA-pr-%E8%A2%AB%E5%90%88%E5%B9%B6%E4%BA%86/</link>
        <pubDate>Thu, 21 Aug 2025 10:48:37 +0800</pubDate>
        
        <guid>https://mahaoliang.tech/p/%E6%88%91%E5%9C%A8%E5%BC%80%E6%BA%90%E4%B9%8B%E5%A4%8F%E4%B8%BA-openeuler-%E6%8F%90%E4%BA%A4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA-pr-%E8%A2%AB%E5%90%88%E5%B9%B6%E4%BA%86/</guid>
        <description>&lt;p&gt;今年我有幸参加了&lt;a class=&#34;link&#34; href=&#34;https://summer-ospp.ac.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;开源之夏 (Summer OSPP)&lt;/a&gt; 活动，并成功中选了 &lt;a class=&#34;link&#34; href=&#34;https://summer-ospp.ac.cn/org/prodetail/25b970448&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;面向 openEuler distroless 镜像的 SDF 自动生成工具开发&lt;/a&gt; 项目。&lt;/p&gt;
&lt;p&gt;就在几天前，我收到了 Gitee 的合并通知。那一刻，我感觉自己几个月来的努力都有了最好的回报。经过一段时间的开发、学习和与华为老师的深入交流，我提交的 &lt;del&gt;两&lt;/del&gt; 四个 PR 终于先后被合并了！这不仅仅是代码的合入，对我而言意义重大，毕竟这不再是个人玩具项目，而是为华为 &lt;a class=&#34;link&#34; href=&#34;https://openeuler.org&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;openEuler&lt;/a&gt; 生态的基础软件贡献代码。我想借此机会，分享一下这段令人兴奋的旅程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://summer-ospp.ac.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;开源之夏&lt;/a&gt; 是中国科学院软件研究所发起的“开源软件供应链点亮计划”系列活动，由中国科学院软件研究所与华为共同主办、中科南京软件技术研究院承办。开源之夏为学生提供了接触和贡献高质量开源项目的机会，通过真实的开源项目实践，培养和发掘优秀的开发者，促进优秀开源软件社区的蓬勃发展，助力开源软件供应链建设。开源之夏于 2020 年正式发起，今年已经是第六届，该活动已成为国内开源社区中极具影响力的人才培养平台。
&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202508231635877.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;开源之夏&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2025 年的开源之夏联合了全球 182 个开源社区，共发布了 566 个项目任务，覆盖了操作系统、人工智能、数据库、云原生、RISC-V 等多个前沿技术领域，吸引了全球 450 所高校，两千多名学生的报名，提交了项目申请书 1176 份，最终 518 名学生中选。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202508231636312.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;开源之夏&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;我的任务为-splitter-打造-sdf-自动生成器&#34;&gt;我的任务：为 &lt;code&gt;splitter&lt;/code&gt; 打造 SDF 自动生成器&lt;/h2&gt;
&lt;p&gt;首先简单介绍一下我参与的项目 &lt;a class=&#34;link&#34; href=&#34;https://gitee.com/openeuler/splitter&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;splitter&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在容器化的世界里，我们追求更小、更安全的镜像。openEuler 的 &lt;strong&gt;Distroless&lt;/strong&gt; 镜像就是为此而生。它的核心思想是，不再完整地打包一个 RPM 软件包，而是将其精细地“切分”成多个功能独立的“&lt;strong&gt;Slice&lt;/strong&gt;”，软件包之间的依赖关系也就更精细地表现为 &lt;code&gt;slice&lt;/code&gt; 之间的依赖。然后我们以 &lt;code&gt;slice&lt;/code&gt; 为最小构建单元生成最终的 &lt;code&gt;distroless&lt;/code&gt; 镜像，可以有效减少冗余文件，进而降低安全风险。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202508231706963.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Slice&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，软件包 B 依赖于软件包 A 等价于 B_slice1 和 B_slice2 依赖于 A_slice1、A_slice2，在生成 B 的应用镜像时，可以不再打包 A_slice3 所包含的文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;splitter&lt;/code&gt; 通过解析 RPM 软件包，并根据预定义的规则文件 &lt;strong&gt;SDF (Slice Definition File)&lt;/strong&gt;，将软件包切分成多个 &lt;code&gt;slice&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SDF (Slice Definition File)&lt;/strong&gt; 精准定义每个软件包的拆分规则。目前，所有的 SDF 文件都由社区专家手工编写，存放在 &lt;a class=&#34;link&#34; href=&#34;https://gitee.com/openeuler/slice-releases/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;slice-releases&lt;/a&gt; 仓库中。当软件包数量和版本不断增多时，手工编写 SDF 就成了一个巨大的瓶颈。&lt;/p&gt;
&lt;p&gt;我的任务，就是为&lt;code&gt;splitter&lt;/code&gt;开发一个&lt;code&gt;gen&lt;/code&gt;命令，实现 SDF 文件的&lt;strong&gt;自动化生成&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;sdf-生成器的核心实现&#34;&gt;SDF 生成器的核心实现&lt;/h2&gt;
&lt;p&gt;我的任务是自动化生成 SDF 文件，但在开始之前，我们首先要理解：&lt;strong&gt;SDF 文件究竟是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;sdf-文件的构成&#34;&gt;SDF 文件的构成&lt;/h3&gt;
&lt;p&gt;一个 SDF（Slice Definition File）文件，本质上是一个 YAML 格式的“软件包拆分说明书”。它精确地定义了一个 RPM 包如何被拆解成多个功能独立的、可按需组合的“Slice”。一个典型的 SDF（以&lt;code&gt;brotli.yaml&lt;/code&gt;为例）包含两个核心部分：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;package&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;brotli&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;deps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;brotli_copyright&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;slices&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;libs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;deps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;glibc_libs&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;contents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;common&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;/usr/lib64/libbrotlicommon.so.1*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;/usr/lib64/libbrotlidec.so.1*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;/usr/lib64/libbrotlienc.so.1*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;copyright&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;contents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;common&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;/usr/share/licenses/brotli/LICENSE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;slices&lt;/code&gt; (切片)&lt;/strong&gt;：这是主体部分，定义了包内每个文件的归属。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;contents&lt;/code&gt;&lt;/strong&gt;: 列出了这个 Slice 包含的所有文件路径。比如，&lt;code&gt;brotli_libs&lt;/code&gt; slice 包含了所有的&lt;code&gt;.so&lt;/code&gt;库文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;deps&lt;/code&gt; (依赖)&lt;/strong&gt;：定义了 Slice 之间的依赖关系。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;deps&lt;/code&gt;&lt;/strong&gt;: 列出了要让当前 Slice 正常工作，需要依赖哪些其他的 Slice。比如，&lt;code&gt;brotli_libs&lt;/code&gt; slice 依赖于&lt;code&gt;glibc_libs&lt;/code&gt;，因为&lt;code&gt;brotli&lt;/code&gt;的库函数调用了&lt;code&gt;glibc&lt;/code&gt;的底层功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;sdf-的自动化生成流程&#34;&gt;SDF 的自动化生成流程&lt;/h3&gt;
&lt;p&gt;理解了 SDF 的构成后，我设计了一套自动化的流水线来生成它。整个流程就像一个工厂的生产线，每一步都有明确的输入和输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202508231810609.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;flow&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;下载 (Download)&lt;/strong&gt;: 首先，从 openEuler 的仓库中下载指定的目标 RPM 包。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解压 (Extract)&lt;/strong&gt;: 将 RPM 包解压到一个临时目录，暴露出其内部的所有文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件分类 (Classify Files)&lt;/strong&gt;: 遍历所有文件，根据一系列规则，将它们分配到不同的 Slice 中。&lt;strong&gt;这是填充 SDF 中&lt;code&gt;slices&lt;/code&gt;和&lt;code&gt;contents&lt;/code&gt;部分的核心步骤。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依赖分析 (Analyze Dependencies)&lt;/strong&gt;: 对分类好的 Slice（特别是包含二进制文件和库的）进行分析，找出它们之间的依赖关系。&lt;strong&gt;这是填充 SDF 中&lt;code&gt;deps&lt;/code&gt;部分的核心步骤。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成 SDF (Generate)&lt;/strong&gt;: 最后，将分类和依赖分析的结果，按照 SDF 的 YAML 格式，写入到最终的文件中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这条流水线中，最核心、最具技术挑战性的，无疑是“文件分类”和“依赖分析”这两个环节。&lt;/p&gt;
&lt;h3 id=&#34;文件分类原理&#34;&gt;文件分类原理&lt;/h3&gt;
&lt;p&gt;文件分类就是确定 RPM 包里的每一个文件，应该属于哪个 Slice。&lt;/p&gt;
&lt;p&gt;一个软件包通常包含可执行文件、库文件、配置文件、版权声明等。我实现了一个基于规则的智能分类器，它的工作思路是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;建立规则&lt;/strong&gt;：我分析了大量手工编写的 SDF，总结出了一套通用的分类“约定”。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以&lt;code&gt;/etc/&lt;/code&gt;开头的文件 -&amp;gt; 归入&lt;code&gt;_config&lt;/code&gt; slice。&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;/usr/bin/&lt;/code&gt;或&lt;code&gt;/usr/sbin/&lt;/code&gt;开头的文件 -&amp;gt; 归入&lt;code&gt;_bins&lt;/code&gt; slice。&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;/usr/lib*/&lt;/code&gt;开头且包含&lt;code&gt;.so&lt;/code&gt;的文件 -&amp;gt; 归入&lt;code&gt;_libs&lt;/code&gt; slice。&lt;/li&gt;
&lt;li&gt;包含&lt;code&gt;LICENSE&lt;/code&gt;, &lt;code&gt;COPYING&lt;/code&gt;等字样的文件 -&amp;gt; 归入&lt;code&gt;_copyright&lt;/code&gt; slice。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;精确识别&lt;/strong&gt;：仅靠路径还不够。比如，在&lt;code&gt;/usr/bin&lt;/code&gt;目录下，既有真正的二进制可执行文件，也可能混杂着 Shell 脚本或 Bash 内建命令的占位符。为了精确区分，我的分类器会调用 Linux 的&lt;code&gt;file&lt;/code&gt;命令对每个文件进行“身份鉴定”。只有&lt;code&gt;file&lt;/code&gt;命令确认是“ELF executable”的文件，才会被归入&lt;code&gt;_bins&lt;/code&gt; slice，从而保证了分类的准确性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这个分类器，我们就能自动地将一个 RPM 包内的上百个文件，有条不紊地分配到不同的&lt;code&gt;slices&lt;/code&gt;中。&lt;/p&gt;
&lt;h3 id=&#34;slice-依赖分析原理&#34;&gt;Slice 依赖分析原理&lt;/h3&gt;
&lt;p&gt;依赖分析就是找出每个 Slice（尤其是&lt;code&gt;_bins&lt;/code&gt;和&lt;code&gt;_libs&lt;/code&gt;）依赖了哪些外部的 Slice。&lt;/p&gt;
&lt;p&gt;这是技术上最关键的一步。一个二进制文件运行时，需要操作系统动态链接器加载它所依赖的共享库（&lt;code&gt;.so&lt;/code&gt;文件），我需要自动追溯这条“依赖链”。&lt;/p&gt;
&lt;p&gt;我的依赖分析器采用了一个三步走的策略，来模拟动态链接器的行为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;静态解析“需求”&lt;/strong&gt;：对于&lt;code&gt;_bins&lt;/code&gt;和&lt;code&gt;_libs&lt;/code&gt;中的每个 ELF 文件，我使用&lt;code&gt;readelf -d&lt;/code&gt;命令。这是一个静态分析工具，它能安全地读取文件头，并列出这个文件在运行时“需要 (&lt;code&gt;NEEDED&lt;/code&gt;)”哪些共享库。例如，&lt;code&gt;readelf&lt;/code&gt;会告诉我们&lt;code&gt;brotli&lt;/code&gt;的库需要&lt;code&gt;libc.so.6&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全系统“寻址”&lt;/strong&gt;：知道了需要&lt;code&gt;libc.so.6&lt;/code&gt;，下一步就是要在系统中找到它。我通过查询&lt;code&gt;ldconfig -p&lt;/code&gt;维护的系统库缓存，可以快速地将一个库名（&lt;code&gt;libc.so.6&lt;/code&gt;）映射到它在文件系统上的绝对路径（例如&lt;code&gt;/usr/lib64/libc.so.6&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;反向“溯源”&lt;/strong&gt;：拿到了库文件的绝对路径，最后一步就是确定它的“主人”。我使用&lt;code&gt;rpm -qf &amp;lt;文件路径&amp;gt;&lt;/code&gt;命令，它可以精确地反向查询出这个文件是由哪个 RPM 包提供的。例如，&lt;code&gt;rpm -qf /usr/lib64/libc.so.6&lt;/code&gt;会返回&lt;code&gt;glibc&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此，完整的依赖链就建立起来了：&lt;strong&gt;&lt;code&gt;brotli_libs&lt;/code&gt; -&amp;gt; (需要&lt;code&gt;libc.so.6&lt;/code&gt;) -&amp;gt; (位于&lt;code&gt;/usr/lib64/libc.so.6&lt;/code&gt;) -&amp;gt; (属于&lt;code&gt;glibc&lt;/code&gt;包) -&amp;gt; (因此依赖&lt;code&gt;glibc_libs&lt;/code&gt;)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过自动化这个流程，我的工具就能为每个 Slice 精确地填充出它的&lt;code&gt;deps&lt;/code&gt;列表。&lt;/p&gt;
&lt;h3 id=&#34;无法逾越的环境依赖&#34;&gt;无法逾越的环境依赖&lt;/h3&gt;
&lt;p&gt;当我完成了上述完整的自动化流水线，并满怀信心地在一个最小化的 openEuler 环境上进行测试时，我遇到了第一个真正的挑战。&lt;/p&gt;
&lt;p&gt;我的依赖分析器在第 2 步“全系统寻址”时失败了！原因很简单：&lt;strong&gt;我测试用的这个最小化系统里，根本就没有预装待分析包所需要的所有依赖库。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个问题是致命的。它意味着我的工具能否成功运行，完全取决于它所在的宿主环境是否“恰好”是完备的。这对于一个追求自动化和可靠性的工具来说，是不可接受的。&lt;/p&gt;
&lt;h2 id=&#34;引入-docker沙箱化分析&#34;&gt;引入 Docker“沙箱化”分析&lt;/h2&gt;
&lt;p&gt;在 &lt;a class=&#34;link&#34; href=&#34;https://gitee.com/openeuler/splitter/pulls/19&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PR review&lt;/a&gt; 的过程中，华为鲁卫军老师建议我使用 &lt;code&gt;chroot&lt;/code&gt; 或容器技术来隔离分析环境，避免安装待分析的 RPM 包污染宿主机环境。基于这个建议，我采用 Docker 实现了环境隔离，新的流程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;构建基础镜像&lt;/strong&gt;：编写了一个 &lt;code&gt;Dockerfile&lt;/code&gt;，它会预先构建一个包含了 &lt;code&gt;splitter&lt;/code&gt; 工具本身，以及所有依赖（如 &lt;code&gt;python-dnf&lt;/code&gt;, &lt;code&gt;binutils&lt;/code&gt; 等）的“SDF 生成器基础镜像”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;隔离的分析流程&lt;/strong&gt;: 当运行 &lt;code&gt;gen-sdf-docker.sh&lt;/code&gt; 时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它会自动使用上述的基础镜像启动一个干净、一次性的 Docker 容器。&lt;/li&gt;
&lt;li&gt;在容器内部，它只执行必要的操作：dnf install &lt;!-- raw HTML omitted --&gt;来安装待分析包及其运行时依赖。&lt;/li&gt;
&lt;li&gt;然后调用 splitter gen 命令执行核心的分析逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析结束后，容器会被自动销毁，对用户的宿主系统环境无影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;意外的惊喜第一个成功合并的-pr-竟是副产品&#34;&gt;意外的惊喜：第一个成功合并的 PR 竟是“副产品”！&lt;/h2&gt;
&lt;p&gt;为了实现上述的 Docker 化流程，我需要一个包含了&lt;code&gt;splitter&lt;/code&gt;工具本身的基础镜像。这时，鲁老师又给了我一个的建议：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;构建 splitter 的 Dockerfile 可以提交到 openEuler 的官方镜像仓库去 &lt;a class=&#34;link&#34; href=&#34;https://gitee.com/openeuler/openeuler-docker-images&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gitee.com/openeuler/openeuler-docker-images&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这让我意识到，这个为了我自己的工具而制作的镜像，本身就可以成为一个交付给社区的“官方应用镜像”！于是，我仔细阅读了官方镜像的贡献指南，编写了&lt;code&gt;Dockerfile&lt;/code&gt;和相关的元数据，并提交了&lt;a class=&#34;link&#34; href=&#34;https://gitee.com/openeuler/openeuler-docker-images/pulls/866&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PR 到 &lt;code&gt;openeuler-docker-images&lt;/code&gt; 仓库&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;没想到，这个作为我主线任务“副产品”的 PR，竟然先一步通过了审核，正式合并！那一刻的喜悦难以言表。&lt;strong&gt;我的第一个被大型开源项目合并的 PR，就这样诞生了！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202508231830231.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;PR&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;主线达成为华为基础软件贡献代码&#34;&gt;主线达成：为华为基础软件贡献代码！&lt;/h2&gt;
&lt;p&gt;有了官方镜像的加持，我为 &lt;code&gt;splitter&lt;/code&gt; 增加 &lt;code&gt;gen&lt;/code&gt; 命令的&lt;a class=&#34;link&#34; href=&#34;https://gitee.com/openeuler/splitter/pulls/19&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PR&lt;/a&gt;也很快被顺利合并了，这标志着我的开源之夏项目取得了阶段性的成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202508231835614.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;PR&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这次的感觉又有所不同。虽然我自己在 &lt;a class=&#34;link&#34; href=&#34;https://github.com/mahaoliang2005&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub&lt;/a&gt; 上也发布过一些个人项目，但为 &lt;code&gt;openEuler/splitter&lt;/code&gt; 这样重量级的基础软件贡献核心代码，意义完全不一样。它服务于整个 openEuler 的云原生生态，背后是华为和众多社区开发者的努力。能够成为其中一员，哪怕只是贡献了一小部分，也让我感到无比自豪。&lt;/p&gt;
&lt;h2 id=&#34;后续工作&#34;&gt;后续工作&lt;/h2&gt;
&lt;p&gt;开源贡献不是一次性的，而是一个持续迭代的过程。在核心功能合并后，我立刻投入到了后续的优化工作中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;提供便携的工具入口&lt;/strong&gt;：我提交了新的 &lt;a class=&#34;link&#34; href=&#34;https://gitee.com/openeuler/splitter/pulls/20&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PR #20&lt;/a&gt;，为项目增加了一个&lt;code&gt;splitter-docker.sh&lt;/code&gt;脚本。它封装了所有 Docker 操作，让任何用户都可以通过一条简单的命令，使用官方镜像来运行&lt;code&gt;splitter&lt;/code&gt;的&lt;code&gt;cut&lt;/code&gt;和&lt;code&gt;gen&lt;/code&gt;命令，极大地降低了使用门槛。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在写文章的过程中，这个 PR 也审核通过，成功合并了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202508231842928.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;PR&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;更新官方镜像&lt;/strong&gt;：随着&lt;code&gt;splitter&lt;/code&gt;的版本迭代（比如&lt;code&gt;gen&lt;/code&gt;命令的加入），官方镜像也需要更新。我提交了&lt;a class=&#34;link&#34; href=&#34;https://gitee.com/openeuler/openeuler-docker-images/pulls/1023&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;新的 PR #1023&lt;/a&gt;来将镜像中的&lt;code&gt;splitter&lt;/code&gt;版本升级到最新。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;文章还没发布，这个 PR 也审核通过，成功合并了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202508231918280.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;PR&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这让我深刻体会到，一个功能的完成，往往是另一个优化的开始。&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;这次开源之夏的经历，让我从一个开源的旁观者，变成了一个真正的参与者和贡献者。我不仅学到了如何设计和实现一个健壮的工具，更学会了如何在社区中沟通、协作，以及如何遵循大型项目的规范和流程。&lt;/p&gt;
&lt;p&gt;感谢开源之夏提供了这么好的平台，感谢 openEuler 社区的开放和包容，更要感谢我的导师鲁卫军老师的一路悉心指导。这段旅程才刚刚开始，未来，我希望能为开源世界贡献更多力量。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>使用 1Password 和 SSH Agent Forwarding 提升远程开发体验</title>
        <link>https://mahaoliang.tech/p/%E4%BD%BF%E7%94%A8-1password-%E5%92%8C-ssh-agent-forwarding-%E6%8F%90%E5%8D%87%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C/</link>
        <pubDate>Tue, 29 Jul 2025 21:05:21 +0800</pubDate>
        
        <guid>https://mahaoliang.tech/p/%E4%BD%BF%E7%94%A8-1password-%E5%92%8C-ssh-agent-forwarding-%E6%8F%90%E5%8D%87%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C/</guid>
        <description>&lt;p&gt;作为开发者，我们经常需要通过 SSH 连接到远程 Linux 服务器进行开发。工具如 VS Code 的 Remote-SSH 插件，让我们几乎感觉不到自己是在一台远程机器上工作。但一个常见的痛点随之而来：&lt;strong&gt;SSH 密钥管理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们希望：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 SSH 密钥登录服务器，并向 Git 仓库（如 GitHub）推送代码。&lt;/li&gt;
&lt;li&gt;对每一次 Git 提交进行签名，以验证提交的来源。&lt;/li&gt;
&lt;li&gt;最重要的一点：&lt;strong&gt;不希望将包含私钥的任何文件拷贝到远程服务器上&lt;/strong&gt;，以防服务器被入侵导致私钥泄露。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;幸运的是，通过 1Password 内置的 SSH Agent 和 SSH Agent Forwarding 技术，我们可以完美地解决这个问题。本文将带你一步步配置，实现安全、无缝的远程开发流程。&lt;/p&gt;
&lt;h2 id=&#34;核心概念简介&#34;&gt;核心概念简介&lt;/h2&gt;
&lt;p&gt;在开始之前，我们先简单了解几个关键概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SSH Agent (SSH 代理)&lt;/strong&gt;：它就像一个临时的密钥管理员。你可以在会话开始时，将解密的私钥（decrypted private key）加载到 Agent 中。之后，任何需要使用该密钥的 SSH 操作都会向 Agent 请求，而无需你反复输入密码。当你关闭终端会话时，Agent 也会随之关闭，密钥被安全地清除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1Password SSH Agent&lt;/strong&gt;：1Password 8 及以上版本内置了一个功能强大的 SSH Agent。它将你的 SSH 私钥安全地存储在 1Password 保管库中，并通过一个安全的套接字文件（socket file）与你的系统交互。这意味着你的私钥永远不会以明文形式存在于磁盘上，所有使用请求都需要经过 1Password 的授权（例如 Touch ID 或主密码）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SSH Agent Forwarding (SSH 代理转发)&lt;/strong&gt;：这是一个非常强大的 SSH 功能。当你从本地电脑 SSH 到远程服务器时，它可以建立一个安全通道，将远程服务器上需要密钥认证的操作请求，“转发”回你的&lt;strong&gt;本地电脑&lt;/strong&gt;，交由你本地的 SSH Agent 来处理。这样一来，远程服务器本身完全不需要存储任何私钥。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;我们的目标流程&#34;&gt;我们的目标流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在本地电脑上，1Password 管理着我们的 SSH 私钥。&lt;/li&gt;
&lt;li&gt;通过 VS Code Remote-SSH 或终端连接到远程服务器，并启用 Agent Forwarding。&lt;/li&gt;
&lt;li&gt;在远程服务器上，执行 &lt;code&gt;git push&lt;/code&gt; 时，认证请求被转发回本地，由 1Password 处理。&lt;/li&gt;
&lt;li&gt;在远程服务器上，执行 &lt;code&gt;git commit&lt;/code&gt; 时，签名请求也被转发回本地，由 1Password 处理和授权。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;配置流程&#34;&gt;配置流程&lt;/h2&gt;
&lt;h3 id=&#34;前提条件&#34;&gt;前提条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;你已经安装了 1Password 8 或更高版本的桌面客户端。&lt;/li&gt;
&lt;li&gt;你的 SSH 密钥已经创建并保存在 1Password 的 &lt;code&gt;SSH 密钥&lt;/code&gt; 分类中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第一步配置本地电脑让-ssh-使用-1password&#34;&gt;第一步：配置本地电脑，让 SSH 使用 1Password&lt;/h3&gt;
&lt;p&gt;首先，我们需要告诉本地的 SSH 客户端，让它把所有密钥相关的请求都交给 1Password 处理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;在 1Password 中启用 SSH Agent&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开 1Password 桌面应用。&lt;/li&gt;
&lt;li&gt;进入 &lt;code&gt;设置&lt;/code&gt; -&amp;gt; &lt;code&gt;开发者&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;勾选 &lt;code&gt;使用 SSH 代理&lt;/code&gt;。
&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202507292109013.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ssh agent&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;配置本地 SSH 配置文件 (&lt;code&gt;~/.ssh/config&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考 1password 的&lt;a class=&#34;link&#34; href=&#34;https://developer.1password.com/docs/ssh/get-started/#step-4-configure-your-ssh-or-git-client&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;，我们有两种方式告诉 SSH 客户端 Agent 在哪里：&lt;code&gt;IdentityAgent&lt;/code&gt; 指令和 &lt;code&gt;SSH_AUTH_SOCK&lt;/code&gt; 环境变量。推荐使用 &lt;code&gt;IdentityAgent&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;编辑你&lt;strong&gt;本地电脑&lt;/strong&gt;上的 &lt;code&gt;~/.ssh/config&lt;/code&gt; 文件（如果不存在，请创建它）。在文件顶部添加以下内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 告诉所有 SSH 连接 (*) 都使用 1Password 的 Agent&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Host *
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  IdentityAgent &lt;span class=&#34;s2&#34;&gt;&amp;#34;~/Library/Group Containers/2BUA8C4S2C.com.1password/t/agent.sock&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;验证配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;本地电脑&lt;/strong&gt;的终端里运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ssh-add -l
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果配置成功，它会列出你在 1Password 中存储的所有 SSH 密钥的公钥指纹。这证明你的本地 SSH 客户端已经成功与 1Password 对接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;第二步配置连接启用-agent-forwarding&#34;&gt;第二步：配置连接，启用 Agent Forwarding&lt;/h3&gt;
&lt;p&gt;现在，我们需要在连接到特定远程服务器时，启用 Agent Forwarding 功能。最佳实践依然是修改 &lt;code&gt;~/.ssh/config&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;继续编辑你&lt;strong&gt;本地电脑&lt;/strong&gt;上的 &lt;code&gt;~/.ssh/config&lt;/code&gt; 文件，为你的服务器添加一个专有配置块：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 给你的远程服务器起一个别名，方便连接&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Host my-dev-server
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    HostName &amp;lt;your_server_ip_or_domain&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    User mahaoliang
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ForwardAgent yes   &lt;span class=&#34;c1&#34;&gt;# &amp;lt;-- 关键！启用 Agent Forwarding&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Host my-dev-server&lt;/code&gt;: 这是你连接时使用的快捷别名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HostName&lt;/code&gt;: 服务器的实际 IP 或域名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;User&lt;/code&gt;: 你在服务器上的用户名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ForwardAgent yes&lt;/code&gt;: 这就是开启 Agent Forwarding 的开关。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，你可以通过 &lt;code&gt;ssh my-dev-server&lt;/code&gt; 或在 VS Code Remote-SSH 中直接连接到 &lt;code&gt;my-dev-server&lt;/code&gt;，转发功能会自动启用。&lt;/p&gt;
&lt;h3 id=&#34;第三步配置远程服务器上的-git&#34;&gt;第三步：配置远程服务器上的 Git&lt;/h3&gt;
&lt;p&gt;这是最后一步，也是最关键的一步。我们需要告诉远程服务器上的 Git，如何使用我们转发过来的 SSH Agent 进行提交签名。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接并验证转发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，连接到你的远程服务器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ssh my-dev-server
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;连接成功后，在&lt;strong&gt;远程服务器&lt;/strong&gt;的终端上，再次运行验证命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ssh-add -l
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果 Agent Forwarding 正常工作，这里显示的输出应该和你&lt;strong&gt;本地电脑&lt;/strong&gt;的输出&lt;strong&gt;完全一样&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;如果提示“Could not open a connection to your authentication agent.”，请检查 SSH 服务配置，确保 &lt;code&gt;AllowAgentForwarding yes&lt;/code&gt; 已启用。&lt;/p&gt;
&lt;p&gt;使用 vim 打开 &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt; 文件，找到 &lt;code&gt;AllowAgentForwarding&lt;/code&gt; 配置项，设置为 &lt;code&gt;yes&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;AllowAgentForwarding yes
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;保存后重启 SSH 服务使配置生效：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;systemctl restart sshd
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;再次连接你的远程服务器，执行 &lt;code&gt;ssh-add -l&lt;/code&gt;，确认 Agent Forwarding 正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;获取用于签名的公钥&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Git 需要知道用哪个具体的密钥来签名。我们需要提供完整的公钥字符串作为标识。在&lt;strong&gt;远程服务器&lt;/strong&gt;上运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ssh-add -L
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这个命令会列出 Agent 中所有密钥的完整公钥。复制你想要用来签名的那一行，它看起来像这样：
&lt;code&gt;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAICxxxxxxxxxxxxxxxxxxxx your-key-comment&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;配置远程服务器的 &lt;code&gt;.gitconfig&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在，编辑你&lt;strong&gt;远程服务器&lt;/strong&gt;上的 &lt;code&gt;~/.gitconfig&lt;/code&gt; 文件。将你原来的配置更新如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;[user]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;na&#34;&gt;email&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;mahaoliang@gmail.com
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    name = mahaoliang
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    # 将 signingkey 的值设置为你上一步复制的完整公钥字符串
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    signingkey = ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAICxxxxxxxxxxxxxxxxxxxx your-key-comment&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;[gpg]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 告诉 Git 使用 ssh 程序进行签名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;na&#34;&gt;format&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;ssh&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;[commit]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 让所有提交都默认进行签名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;na&#34;&gt;gpgsign&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最重要的改动在于 &lt;code&gt;signingkey&lt;/code&gt;。我们不再使用一个文件路径，而是直接提供了公钥本身。这让 Git 可以直接向转发过来的 Agent 请求使用这个特定的密钥进行签名。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;大功告成来测试一下吧&#34;&gt;大功告成！来测试一下吧&lt;/h3&gt;
&lt;p&gt;一切准备就绪！在远程服务器上，进入你的任意一个 git 项目，尝试创建一个新提交：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git commit --allow-empty -m &lt;span class=&#34;s2&#34;&gt;&amp;#34;Test: Signed commit with 1Password Agent Forwarding&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;此时，奇妙的事情发生了：你的&lt;strong&gt;本地电脑&lt;/strong&gt;上会弹出 1Password 的授权请求，提示你应用正在请求使用你的 SSH 密钥。通过 Touch ID 或输入主密码授权后，远程服务器上的 &lt;code&gt;git commit&lt;/code&gt; 命令瞬间完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202507292112652.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ssh key&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;最后，检查一下你的提交日志：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git log --show-signature -1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;你将会看到类似下面的输出，&lt;code&gt;Good signature&lt;/code&gt; 明确告诉你，这次提交已经由你的密钥成功签名！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;commit &amp;lt;commit_hash&amp;gt; (HEAD -&amp;gt; main)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Good &amp;#34;git&amp;#34; signature for mahaoliang@gmail.com with ED25519 key SHA256:GKaU0ZCgehQ73X...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Author: mahaoliang &amp;lt;mahaoliang@gmail.com&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Date:   ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    Test: Signed commit with 1Password Agent Forwarding
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;下图展示了使用 1Password 和 SSH Agent Forwarding 进行远程 Git 提交签名的核心流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202507301201877.svg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;flow&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图中组件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;本地电脑 (Local)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;开发者&lt;/strong&gt;：操作的发起者。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1Password SSH Agent&lt;/strong&gt;：安全存储私钥，并处理所有签名请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH Client&lt;/strong&gt;：本地的 SSH 程序，配置为使用 1Password Agent 并启用转发。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;远程服务器 (Remote)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;远程终端&lt;/strong&gt;：开发者在服务器上的工作界面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Git&lt;/strong&gt;：版本控制工具，配置为使用 SSH 进行签名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH Daemon&lt;/strong&gt;：服务器上的 SSH 服务，负责建立安全连接和转发请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;交互流程详解&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;发起提交&lt;/strong&gt;：开发者在&lt;strong&gt;远程终端&lt;/strong&gt;中执行 &lt;code&gt;git commit&lt;/code&gt; 命令。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求签名&lt;/strong&gt;：&lt;strong&gt;Git&lt;/strong&gt; 根据配置，向 SSH 服务请求使用密钥进行签名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;转发请求&lt;/strong&gt;：远程服务器的 &lt;strong&gt;SSH Daemon&lt;/strong&gt; 将签名请求通过加密的 SSH 隧道&lt;strong&gt;转发回&lt;/strong&gt;本地电脑的 &lt;strong&gt;SSH Client&lt;/strong&gt;。这是 Agent Forwarding 的核心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求 1Password&lt;/strong&gt;：本地的 &lt;strong&gt;SSH Client&lt;/strong&gt; 将请求交给 &lt;strong&gt;1Password SSH Agent&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求用户授权&lt;/strong&gt;：&lt;strong&gt;1Password&lt;/strong&gt; 在本地电脑上弹出提示，向&lt;strong&gt;开发者&lt;/strong&gt;请求授权。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户授权&lt;/strong&gt;：&lt;strong&gt;开发者&lt;/strong&gt;在本地进行身份验证（如 Touch ID 或主密码）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回签名&lt;/strong&gt;：授权成功后，&lt;strong&gt;1Password&lt;/strong&gt; 生成签名并返回给本地 &lt;strong&gt;SSH Client&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回签名至远程&lt;/strong&gt;：签名通过 SSH 隧道被安全地&lt;strong&gt;传回&lt;/strong&gt;远程服务器的 &lt;strong&gt;SSH Daemon&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完成提交&lt;/strong&gt;：远程的 &lt;strong&gt;Git&lt;/strong&gt; 进程收到有效的签名，成功创建提交，并在&lt;strong&gt;远程终端&lt;/strong&gt;中显示成功信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过以上配置，我们构建了一个既安全又便捷的远程开发工作流。你的私钥始终安全地躺在本地的 1Password 保管库中，而远程服务器上的所有 Git 操作（认证和签名）都能够无缝、安全地使用它。这不仅提升了安全性，也大大简化了多服务器环境下的密钥管理，让你能更专注于编码本身。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>一步步教你在 VMware Fusion 中实现与 Linux 虚拟机的文件共享</title>
        <link>https://mahaoliang.tech/p/%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%95%99%E4%BD%A0%E5%9C%A8-vmware-fusion-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%8E-linux-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</link>
        <pubDate>Wed, 09 Jul 2025 11:41:57 +0800</pubDate>
        
        <guid>https://mahaoliang.tech/p/%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%95%99%E4%BD%A0%E5%9C%A8-vmware-fusion-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%8E-linux-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</guid>
        <description>&lt;p&gt;对于许多在 macOS 上工作的开发者来说，VMware Fusion 就像一把瑞士军刀，让我们能随时拥有一个纯净、独立的 Linux 环境。无论是进行 Linux 系统编程、用 Python 做 Linux 系统工具开发，还是部署和测试应用程序，虚拟机都为我们提供了一个完美的沙盒。&lt;/p&gt;
&lt;p&gt;然而，当你将所有的代码、项目文件和配置文件都存放在 Linux 虚拟机中，万一哪天虚拟机意外崩溃、无法启动，所有的心血都可能付诸东流。&lt;/p&gt;
&lt;p&gt;好消息是，VMware Fusion 提供了一个极其强大的功能，&lt;strong&gt;“共享文件夹”（Shared Folders）&lt;/strong&gt;，通过简单的配置，我们可以将 macOS 上的任意一个文件夹，直接“挂载”到 Linux 虚拟机的系统中，让它看起来就像是 Linux 自己的一个目录。&lt;/p&gt;
&lt;p&gt;这意味着，你可以在 macOS 或 Linux 上修改代码，因为它们都是同一份，同时你也可以使用 Time Machine 或其他云盘来实现代码的备份，即方便又安全。&lt;/p&gt;
&lt;p&gt;本文将作为你的向导，手把手带你完成从 VMware Fusion 的配置，到 Linux 系统配置的全部过程。让我们开始吧！&lt;/p&gt;
&lt;h2 id=&#34;准备工作安装-vmware-tools&#34;&gt;准备工作，安装 VMware Tools&lt;/h2&gt;
&lt;p&gt;在开始配置共享之前，我们需要确保环境准备就绪，已经在 VMware Fusion 中安装好一个 Linux 发行版。&lt;/p&gt;
&lt;p&gt;接下来需要在 Linux 虚拟中安装 &lt;strong&gt;VMware Tools&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;你可以把 &lt;strong&gt;VMware Tools&lt;/strong&gt; 理解为是连接 macOS 宿主机和 Linux 虚拟机的“桥梁”或“驱动程序”。像虚拟机屏幕分辨率自适应、鼠标无缝切换、剪贴板共享，以及我们本次的目标&lt;strong&gt;文件夹共享&lt;/strong&gt;，都完全依赖于它。&lt;/p&gt;
&lt;p&gt;对于大多数的 Linux 发行版，官方和社区共同维护了一个开源实现，叫做 &lt;a class=&#34;link&#34; href=&#34;https://github.com/vmware/open-vm-tools&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;open-vm-tools&lt;/a&gt;，它已经预置在大多数 Linux 发行版的软件源中，安装起来非常方便。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;open-vm-tools&lt;/code&gt; 主要由以下几个软件包组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;open-vm-tools&lt;/code&gt;: 这是核心包，提供了最基础的功能，如虚拟机时钟同步、与宿主机的电源操作（正常关机）、心跳检测，以及最重要的，它包含了实现文件夹共享所必需的组件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;open-vm-tools-desktop&lt;/code&gt;: 它在核心包的基础上，增加了改善图形化交互体验的功能，例如剪贴板复制粘贴、窗口大小自适应等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;open-vm-tools-devel&lt;/code&gt; 和 &lt;code&gt;open-vm-tools-debuginfo&lt;/code&gt;: 这两个包分别用于二次开发和调试，普通用户完全不需要关心。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;了解了这些，我们的目标就非常明确了。在虚拟机的命令行终端执行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Ubuntu&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt update
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install open-vm-tools
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# RHEL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo yum install open-vm-tools
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;安装完成后，重启虚拟机，确保所有服务都能正常加载。下一步，我们就去 VMware Fusion 中开启文件共享功能。&lt;/p&gt;
&lt;h2 id=&#34;在-vmware-fusion-中配置共享&#34;&gt;在 VMware Fusion 中配置共享&lt;/h2&gt;
&lt;p&gt;先将 Linux 虚拟机关机，然后进入虚拟机的设置面板，点击“共享”图标，勾选 &lt;strong&gt;“启用共享文件夹”&lt;/strong&gt; 这个复选框，接着，点击下方的 &lt;code&gt;+&lt;/code&gt; 号按钮，准备添加一个具体的共享目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202507191233366.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;启用共享文件夹&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;确保“启用”是勾选状态，并且权限设置为“读与写”，这样你才能在 Linux 中创建和修改文件。&lt;/p&gt;
&lt;p&gt;关闭配置，启动虚拟机，接下来需要在 Linux 中完成共享目录的挂载，就可以访问共享文件夹了。&lt;/p&gt;
&lt;h2 id=&#34;在-linux-虚拟机中访问和挂载&#34;&gt;在 Linux 虚拟机中访问和挂载&lt;/h2&gt;
&lt;p&gt;在最新版的 &lt;code&gt;open-vm-tools&lt;/code&gt; 的支持下，VMware 的共享文件夹通常会被自动挂载到一个系统级的公共目录：&lt;code&gt;/mnt/hgfs&lt;/code&gt; (Host-Guest File System)。&lt;/p&gt;
&lt;p&gt;我们可以先验证一下。打开终端，运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ls /mnt/hgfs
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果能看到你在上一步设置的共享名（如 linux），那么恭喜你，已经成功了！&lt;/p&gt;
&lt;h3 id=&#34;手工挂载&#34;&gt;手工挂载&lt;/h3&gt;
&lt;p&gt;有时 &lt;code&gt;/mnt/hgfs&lt;/code&gt; 目录是空的，这可能是因为权限或 FUSE 服务问题。解决方法是使用 &lt;code&gt;vmhgfs-fuse&lt;/code&gt; 命令手动挂载。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# .host:/ 是一个特殊地址，代表所有已启用的共享&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# /mnt/hgfs 是挂载点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# -o allow_other  允许其他用户(包括你自己)访问，非常重要！&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# -o uid=$(id -u)  将文件所有者设置为当前登录的用户&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# -o gid=$(id -g)  将文件所属组设置为当前登录的用户&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other -o &lt;span class=&#34;nv&#34;&gt;uid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;id -u&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -o &lt;span class=&#34;nv&#34;&gt;gid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;id -g&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;现在 &lt;code&gt;/mnt/hgfs&lt;/code&gt; 目录下就可以看到共享的文件了。&lt;/p&gt;
&lt;p&gt;不过，&lt;code&gt;/mnt/hgfs/linux&lt;/code&gt; 这个路径太深，不方便日常使用，我们想将共享目录挂载在用户主目录下的 &lt;code&gt;~/works&lt;/code&gt; 目录中。&lt;/p&gt;
&lt;p&gt;首先在用户主目录下创建 &lt;code&gt;works&lt;/code&gt; 目录作为挂载的目标。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir ~/works
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后同样使用 &lt;code&gt;vmhgfs-fuse&lt;/code&gt; 工具来执行挂载。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo vmhgfs-fuse .host:/ ~/works -o allow_other -o &lt;span class=&#34;nv&#34;&gt;uid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;id -u&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -o &lt;span class=&#34;nv&#34;&gt;gid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;id -g&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;现在，来验证一下命令效果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ls ~/works
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;你应该能看到 &lt;code&gt;linux&lt;/code&gt; 目录。再进一步查看：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ls ~/works/linux
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;此刻，你看到的就是 macOS 宿主机上那个共享文件夹里的所有内容了！&lt;/p&gt;
&lt;p&gt;然而手动挂载是临时的，一旦你重启虚拟机，挂载就会失效。要实现一劳永逸，请看下一步。&lt;/p&gt;
&lt;h3 id=&#34;实现开机自动挂载&#34;&gt;实现开机自动挂载&lt;/h3&gt;
&lt;p&gt;为了避免每次重启都要手动敲一遍命令，我们需要将挂载信息写入 &lt;code&gt;/etc/fstab&lt;/code&gt; 文件中。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;fstab&lt;/code&gt; 中，我们不能使用 &lt;code&gt;$(id -u)&lt;/code&gt; 这样的命令。需要把用户 ID 和组 ID 的&lt;strong&gt;具体数字&lt;/strong&gt;写进去。运行以下命令查看：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;id
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 你会看到类似 uid=1000(ubuntu) gid=1000(ubuntu) ... 的输出&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通常，第一个创建的用户的 UID 和 GID 都是 &lt;code&gt;1000&lt;/code&gt;。请记下你自己的这两个数字。&lt;/p&gt;
&lt;p&gt;使用你熟悉的编辑器打开 &lt;code&gt;/etc/fstab&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo vi /etc/fstab
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在文件的末尾，添加下面这一行。&lt;strong&gt;请注意，你需要将 &lt;code&gt;/home/ubuntu/works&lt;/code&gt; 替换成你的实际路径，并将 &lt;code&gt;uid=1000,gid=1000&lt;/code&gt; 替换成你自己的 ID。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.host:/ /home/ubuntu/works fuse.vmhgfs-fuse defaults,allow_other,uid&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;1000,gid&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1000&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;以后每次启动 Linux 虚拟机，VMware 的共享文件夹都会自动出现在 &lt;code&gt;~/works&lt;/code&gt; 目录下，方便随时访问。&lt;/p&gt;
&lt;p&gt;大功告成！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>macOS 上 VMWare Fusion 无法安装 OpenEuler 的问题解决</title>
        <link>https://mahaoliang.tech/p/macos-%E4%B8%8A-vmware-fusion-%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85-openeuler-%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</link>
        <pubDate>Mon, 07 Jul 2025 20:26:30 +0800</pubDate>
        
        <guid>https://mahaoliang.tech/p/macos-%E4%B8%8A-vmware-fusion-%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85-openeuler-%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</guid>
        <description>&lt;p&gt;今年我非常幸运地入选了“开源之夏”活动，参与的项目是&lt;a class=&#34;link&#34; href=&#34;https://summer-ospp.ac.cn/org/prodetail/25b970448&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;面向 openEuler distroless 镜像的 SDF 自动生成工具开发&lt;/a&gt;。由于该项目是在 openEuler 上进行开发的，因此，搭建一个稳定可靠的 openEuler 开发环境便成了我的首要任务。&lt;/p&gt;
&lt;p&gt;我的主力设备是一台 M1 芯片的 MacBook Pro，由于去年 &lt;a class=&#34;link&#34; href=&#34;https://blogs.vmware.com/cloud-foundation/2024/11/11/vmware-fusion-and-workstation-are-now-free-for-all-users/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;VMware Fusion 已经对个人用户免费&lt;/a&gt;，所以自然就选择在 VMware Fusion 上安装 openEuler。&lt;/p&gt;
&lt;p&gt;从 openEuler 官方镜像站下载 aarch64 架构最新的 openEuler 24.03 LTS SP1 镜像，使用 VMware Fusion 创建虚拟机，挂载镜像，启动后在 GRUB 界面选择“Install openEuler”，没想到就遇到了问题，安装过程卡住不动了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202507172109472.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;installation frozen&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;习惯性的截图问 &lt;a class=&#34;link&#34; href=&#34;https://aistudio.google.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Google AI studio&lt;/a&gt;，它列举了多个可能的原因，逐一排除确认，发现其中一个分析很有启发性：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个问题可能是由于内核在初始化虚拟显卡时卡住了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是尝试在 openEuler 的安装引导菜单，按 e 键进入编辑模式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202507172140190.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;install&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;继续截图让 Google AI studio 分析：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;您看到的这个界面是 GRUB 引导加载器的编辑模式。它允许您在启动 Linux 内核之前，临时修改传递给内核的参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;video=efifb:off video=VGA-1:640x480...&lt;/code&gt;: &lt;strong&gt;这是一个重要线索&lt;/strong&gt;！这行参数试图禁用 EFI 帧缓冲（&lt;code&gt;efifb:off&lt;/code&gt;）并强制使用一个非常基础的 640x480 分辨率的 VGA 模式。这说明 openEuler 镜像为了在各种（尤其是老旧或奇怪的）硬件上都能启动而加入的“安全模式”参数。然而，这个配置与您的 VMware Fusion 环境冲突，导致了卡死。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;请按照以下步骤操作：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在 &lt;code&gt;linux&lt;/code&gt; 那一行，&lt;strong&gt;手动删除&lt;/strong&gt;掉现有的两个 &lt;code&gt;video=...&lt;/code&gt; 参数，即删除 &lt;code&gt;video=efifb:off&lt;/code&gt; 和 &lt;code&gt;video=VGA-1:640x480-32@60me&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;按 &lt;code&gt;Ctrl+X&lt;/code&gt; 或 &lt;code&gt;F10&lt;/code&gt; 启动。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照 AI 的指示操作，奇迹发生了，系统顺利越过了卡死点，成功进入了图形化的安装界面！&lt;/p&gt;
&lt;p&gt;Gemini 2.5 Pro 太厉害了，遇事不会问 Gemini，准没错！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Zsh 的安装和配置</title>
        <link>https://mahaoliang.tech/p/zsh-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</link>
        <pubDate>Sun, 05 Jan 2025 21:06:07 +0800</pubDate>
        
        <guid>https://mahaoliang.tech/p/zsh-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.zsh.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Zsh&lt;/a&gt; 是一种专门为交互式使用而设计的 Shell，同时也是一种强大的脚本语言，集成了 bash、ksh 和 tcsh 的许多有用特性，并添加了许多独特的功能。&lt;/p&gt;
&lt;p&gt;本文将指导您在 macOS 和 Linux 系统上安装 Zsh、Oh My Zsh 以及其常用插件，并展示如何配置 Oh My Zsh，以打造一个高效的命令行工作环境。&lt;/p&gt;
&lt;h2 id=&#34;安装-zsh&#34;&gt;安装 Zsh&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;macOS &lt;code&gt;brew install zsh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ubuntu &lt;code&gt;sudo apt install zsh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;RHEL &lt;code&gt;sudo yum update &amp;amp;&amp;amp; sudo yum -y install zsh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;验证安装的-zsh-版本&#34;&gt;验证安装的 Zsh 版本&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ zsh --version
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;zsh 5.8.1 &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;x86_64-ubuntu-linux-gnu&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;设置-zsh-为缺省-shell&#34;&gt;设置 Zsh 为缺省 shell&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ chsh -s &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;which zsh&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;退出并重新登录。&lt;/p&gt;
&lt;h2 id=&#34;安装-oh-my-zsh&#34;&gt;安装 Oh My Zsh&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ohmyz.sh/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Oh My Zsh&lt;/a&gt; 是一个开源、社区驱动的 Zsh 配置管理框架，，提供了 300 多个可选插件和 140 多个主题，并且内置了自动更新工具。&lt;/p&gt;
&lt;p&gt;使用下面的命令安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sh -c &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;安装-zsh-autosuggestions&#34;&gt;安装 zsh-autosuggestions&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zsh-users/zsh-autosuggestions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;zsh-autosuggestions&lt;/a&gt; 为 zsh shell 提供了类似 Fish shell 的自动建议功能的插件，该插件可以根据历史记录和自动补全来为用户提供命令建议。&lt;/p&gt;
&lt;p&gt;将插件 clone 到 &lt;code&gt;$ZSH_CUSTOM/plugins&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ git clone https://github.com/zsh-users/zsh-autosuggestions &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;ZSH_CUSTOM&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:-&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;~/.oh-my-zsh/custom&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;/plugins/zsh-autosuggestions
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后在 &lt;code&gt;${HOME}/.zshrc&lt;/code&gt; 启用插件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;plugins&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=(&lt;/span&gt;git zsh-autosuggestions&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在命令行输入命令时，zsh-autosuggestions 会根据命令历史或命令补全进行建议提示。那么如何接受建议呢？&lt;/p&gt;
&lt;p&gt;Bash 和 Zsh 这样的 Unix shell 提供了两种主要的编辑模式：Emacs 模式和 Vi 模式，也就是说可以使用 Emacs 或 Vi 的快捷键来编辑命令行。Emacs 模式是缺省模式。&lt;/p&gt;
&lt;p&gt;在 zsh-autosuggestions 的&lt;a class=&#34;link&#34; href=&#34;https://github.com/zsh-users/zsh-autosuggestions/blob/master/src/config.zsh&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;缺省配置文件&lt;/a&gt;中，定义接受建议的快捷键：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Widgets that accept the entire suggestion&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;((&lt;/span&gt; ! &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;+ZSH_AUTOSUGGEST_ACCEPT_WIDGETS&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;typeset&lt;/span&gt; -ga ZSH_AUTOSUGGEST_ACCEPT_WIDGETS
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nv&#34;&gt;ZSH_AUTOSUGGEST_ACCEPT_WIDGETS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		forward-char
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		end-of-line
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		vi-forward-char
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		vi-end-of-line
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		vi-add-eol
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果命令行处于 Emacs 模式，那么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl-f&lt;/code&gt; 或 &lt;code&gt;ctrl-e&lt;/code&gt; 跳到行尾接受当前的建议&lt;/li&gt;
&lt;li&gt;&lt;code&gt;option-f&lt;/code&gt; 向前前进一个单词并接受建议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样，如果命令行处于 vi 模式，那么就使用对应的 vi 键盘绑定接受建议。&lt;/p&gt;
&lt;h2 id=&#34;配置-oh-my-zsh&#34;&gt;配置 Oh My Zsh&lt;/h2&gt;
&lt;p&gt;Oh My Zsh 有非常多的&lt;a class=&#34;link&#34; href=&#34;https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;内置插件&lt;/a&gt;，你也可以安装第三方插件，就像上面安装的 zsh-autosuggestions。&lt;/p&gt;
&lt;p&gt;Oh My Zsh 也内置了多个 &lt;a class=&#34;link&#34; href=&#34;https://github.com/ohmyzsh/ohmyzsh/wiki/Themes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;主题&lt;/a&gt; 供你选择。&lt;/p&gt;
&lt;p&gt;我们可以编辑 &lt;code&gt;${HOME}/.zshrc&lt;/code&gt;，配置 Oh My Zsh 的插件、主题，以及其他一些定制化设置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 设置主题&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;ZSH_THEME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;bira&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 启用插件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;plugins&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=(&lt;/span&gt;git z zsh-autosuggestions&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 命令别名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;alias&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;mkdir&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;mkdir -v&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;alias&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;mv&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;mv -v&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;alias&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;cp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;cp -v&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;alias&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;rm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;rm -v&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;alias&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;ln&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;ln -v&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 配置zsh-autosuggestions&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;fg=#ff00ff,bg=cyan,bold,underline&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;ZSH_AUTOSUGGEST_STRATEGY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;history&lt;/span&gt; completion&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>大学生计算机专业学习资源不完全列表</title>
        <link>https://mahaoliang.tech/p/%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E4%B8%8D%E5%AE%8C%E5%85%A8%E5%88%97%E8%A1%A8/</link>
        <pubDate>Sat, 24 Aug 2024 15:51:30 +0800</pubDate>
        
        <guid>https://mahaoliang.tech/p/%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E4%B8%8D%E5%AE%8C%E5%85%A8%E5%88%97%E8%A1%A8/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://cdn.mahaoliang.tech/2024/202408241600736.webp&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;6&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;计算机系统与组成原理&#34;&gt;计算机系统与组成原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;极客时间：&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/column/intro/100026001&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入浅出计算机组成原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://csapp.cs.cmu.edu/3e/home.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Computer Systems: A Programmer&amp;rsquo;s Perspective&lt;/a&gt; 从程序员的角度学习计算机系统，了解计算机系统的各个方面，包括硬件、操作系统、编译器和网络。这本书涵盖了数据表示、C 语言程序的机器级表示、处理器架构、程序优化、内存层次结构、链接、异常控制流（异常、中断、进程和 Unix 信号）、虚拟内存和内存管理、系统级 I/O、基本的网络编程和并发编程等概念。这些概念由一系列有趣且实践性强的实验室作业支持。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/playlist?list=PLyboo2CCDSWnhzzzzDQ3OBPrRiIjl-aIE&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Computer Systems: A programmer&amp;rsquo;s Perspective 视频课&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://bottomupcs.com/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Computer Science from the Bottom Up&lt;/a&gt; 采用“从下到上”的方法，从最基础的二进制、数据表示开始，逐步深入计算机内部工作原理，目的是帮助读者真正掌握计算机科学的基础知识。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cpu.land/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Putting the “You” in CPU&lt;/a&gt;  深入探讨了计算机系统的工作原理，包括 CPU 的基本操作、系统调用、多任务处理、内存管理以及程序的执行过程。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/4822685/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;编码&lt;/a&gt;  从二进制编码、数据表示到计算机体系结构、操作系统等多个重要主题，从根本上理解计算机的工作原理。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/35658408/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;漫画计算机原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/36428782/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;趣话计算机底层技术&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/36370606/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;计算机底层的秘密&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/30198087/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;穿越计算机的迷雾&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/35446929/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;嵌入式 C 语言自我修养&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c-语言&#34;&gt;C 语言&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/35384099/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;征服 C 指针&lt;/a&gt; 彻底理解和掌握指针的各种用法和技巧&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/35218533/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;C 专家编程&lt;/a&gt; Sun 公司编译器和 OS 核心开发团队成员，对 C 的历史、语言特性、声明、数组、指针、链接、运行时、内存等问题进行了细致的讲解和深入的分析&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/theokwebb/C-from-Scratch&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;C from Scratch&lt;/a&gt; 一个学习 C 语言的从零开始的路线图，包括推荐的课程、项目和资源，以及进阶到 x86-64 汇编语言和操作系统内部的指导。&lt;/li&gt;
&lt;li&gt;极客时间：&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/column/intro/100100701&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入 C 语言和程序运行原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cdecl.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cdecl&lt;/a&gt; 将 C 语言声明转换为英文描述，例如将这样复杂的声明 &lt;code&gt;void (\*signal(int, void (\*)(int)))(int)&lt;/code&gt; 转换为文字描述：“declare signal as function (int, pointer to function (int) returning void) returning pointer to function (int) returning void”&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;程序运行原理&#34;&gt;程序运行原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://pythontutor.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Online Compiler, Visual Debugger&lt;/a&gt; 独特的逐步可视化调试工具，强烈推荐！&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/26365491/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;程序是怎样跑起来的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/3652388/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;程序员的自我修养：链接、装载与库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如何从对象文件中导入和执行代码  &lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/how-to-execute-an-object-file-part-1/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;part1&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/how-to-execute-an-object-file-part-2/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;part2&lt;/a&gt; &lt;a class=&#34;link&#34; href=&#34;https://blog.cloudflare.com/how-to-execute-an-object-file-part-3/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;part3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://yuriygeorgiev.com/2024/02/19/x86-64-cpu-architecture-the-stack/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;x86/x64 CPU architecture: the stack &amp;amp; stack frames&lt;/a&gt;  x86/x64 CPU 架构中的栈（Stack）及其工作机制，包括栈的数据结构特性、CPU 中栈的管理、栈与堆的区别、栈帧的创建与销毁，以及栈的性能优势。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://fabiensanglard.net/dc/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Driving Compilers&lt;/a&gt; 关于如何使用编译器创建可执行文件的深入知识，涵盖编译器驱动程序、预处理器 cpp、编译器 cc、链接器 ld 以及 Linux 加载器的概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linux-使用&#34;&gt;Linux 使用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;极客时间：&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/course/intro/100029601&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux 实战技能 100 讲&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.oreilly.com/library/view/efficient-linux-at/9781098113391/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Efficient Linux at the Command Line&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://selfhostedserver.com/usingcli&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;像黑客一样使用命令行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.linuxfoundation.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux Foundation&lt;/a&gt; 的认证考试 &lt;a class=&#34;link&#34; href=&#34;https://training.linuxfoundation.org/certification/certified-it-associate/#&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LFCA&lt;/a&gt; 和 &lt;a class=&#34;link&#34; href=&#34;https://training.linuxfoundation.org/certification/linux-foundation-certified-sysadmin-lfcs/#&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LFCS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.oreilly.com/library/view/learning-modern-linux/9781098108939/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Learning Modern Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.linuxfromscratch.org/lfs/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux From Scratch&lt;/a&gt; step-by-step instructions for building your own customized Linux system entirely from source.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linux-内核&#34;&gt;Linux 内核&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/35768243/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux 是怎么工作的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/26931513/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux 技术内幕&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/6097773/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux 内核设计与实现&lt;/a&gt; Linux Kernel Development&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/37015972/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入理解 Linux 进程与内存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;极客时间：&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/column/intro/100058001&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux 内核技术实战课&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;极客时间：&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/column/intro/100094901&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;编程高手必学的内存知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;极客时间：&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/column/intro/100063801&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;容器实战高手课&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/35922722/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入理解 Linux 网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://makelinux.github.io/kernel/map/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;交互式的 Linux 内核地图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linux-系统编程&#34;&gt;Linux 系统编程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/25809330/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux/UNIX系统编程手册&lt;/a&gt; The Linux Programming Interface: A Linux and UNIX System Programming Handbook&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/25900403/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;UNIX 环境高级编程&lt;/a&gt; Advanced Programming in the UNIX Environment&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/illinois-cs241/coursebook&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CS 341: System Programming &lt;/a&gt; 伊利诺伊大学香槟分校 CS 341 课程使用，介绍 C 语言和 Linux 系统编程知识。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络&#34;&gt;网络&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/35013753/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;趣谈网络协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;极客时间：&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/course/intro/100026801&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Web 协议详解与抓包实战&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/24737674/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;图解 TCP/IP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/25863515/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;图解 HTTP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/26941639/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;网络是怎样连接的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据结构和算法&#34;&gt;数据结构和算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;极客时间：&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/column/intro/100017301&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;数据结构与算法之美&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;极客时间：&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/course/intro/100019701&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;算法面试通关 40 讲&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;极客时间：&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/opencourse/intro/100057601&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;常用算法 25 讲&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;极客时间：算法训练营&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/krahets/hello-algo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hello 算法&lt;/a&gt; 动画图解、一键运行的数据结构与算法教程&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://visualgo.net/zh&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;通过动画可视化数据结构和算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;算法刷题&#34;&gt;算法刷题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Leetcode&lt;/a&gt; 一个广受欢迎的在线编程题库&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://neetcode.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Neetcode&lt;/a&gt; 另一个在线编程练习平台&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/youngyangyang04/leetcode-master&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;代码随想录&lt;/a&gt; LeetCode 刷题攻略&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/itcharge/LeetCode-Py&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;算法通关手册&lt;/a&gt; 850+ 道「LeetCode 题目」详细解析&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;综合&#34;&gt;综合&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://csdiy.wiki/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;计算机自学指南&lt;/a&gt; (&lt;a class=&#34;link&#34; href=&#34;https://github.com/PKUFlyingPig/cs-self-learning&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GitHub 仓库&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;YouTube 视频课：&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/watch?v=tpIctyqH29Q&amp;amp;list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Crash Course Computer Science Preview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://missing-semester-cn.github.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;计算机教育中缺失的一课&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://roadmap.sh/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Developer Roadmaps&lt;/a&gt; 为开发者提供学习路线图和指南&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.freecodecamp.org/news/online-coding-classes-for-beginners-2022-guide/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Online Coding Classes – For Beginners&lt;/a&gt;  3000 小时的免费课程，涵盖了编程涉及到的方方面面&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;交互式教程&#34;&gt;交互式教程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://antonz.org/grep-by-example/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Grep by example&lt;/a&gt; 如何使用命令行工具 grep 进行文本搜索的交互式指南&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learngitbranching.js.org/?locale=zh_CN&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Learn Git Branching&lt;/a&gt; 一个交互式的在线教程，帮助用户学习并练习 Git 的基本使用方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在线课程&#34;&gt;在线课程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.educative.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;educative&lt;/a&gt; 为开发者提供交互式在线课程，重点关注技术领域的知识与技能&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.edx.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;edX&lt;/a&gt; 由麻省理工学院（MIT）和哈佛大学共同创立的在线教育平台&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://exercism.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;exercism&lt;/a&gt; 专注于通过有趣且具有挑战性的练习问题、支持建设性同行评审机制来促进积极参与和技能提升，从而培养对各种现代计算范式的熟练掌握。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;技术面试&#34;&gt;技术面试&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Cracking the coding interview book&lt;/a&gt; 一本深受程序员喜爱的面试指南书&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/jwasham/coding-interview-university/blob/main/translations/README-cn.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;编程面试大学&lt;/a&gt; 涵盖了算法、数据结构、面试准备和工作机会等主题，帮助你准备大公司的技术面试&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://interviewing.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;interviewing.io&lt;/a&gt; 一个提供模拟技术面试的平台&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.pramp.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Pramp&lt;/a&gt; 一个模拟面试平台&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.meetapro.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Meetapro&lt;/a&gt; 一个可以找到专业人士进行模拟面试的网站&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ppresume.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PPResume&lt;/a&gt; 一个基于 LaTeX 的简历生成器，目标是帮助人们在几分钟内创建一份精美的简历，并提供极高质量的排版和 PDF 输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;大语言模型&#34;&gt;大语言模型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://learnprompting.org/zh-Hans/docs/intro&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Learn Prompting&lt;/a&gt; 一个开源的、多元化社区构建的课程，旨在提供完整、公正的提示工程知识。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.promptingguide.ai/zh&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;提示工程指南&lt;/a&gt; 介绍大语言模型（LLM）相关的论文研究、学习指南、模型、讲座、参考资料、大语言模型能力及其与其他工具的对接。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://datawhalechina.github.io/llm-cookbook/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;面向开发者的大模型手册&lt;/a&gt; 基于吴恩达大模型系列课程的翻译和复现项目，涵盖了从 Prompt Engineering 到 RAG 开发的全部流程，为国内开发者提供了学习和入门 LLM 相关项目的方式。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://aitutor.liduos.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LLM 应用开发实践笔记&lt;/a&gt; 作者在学习基于大语言模型的应用开发过程中总结出来的经验和方法，包括理论学习和代码实践两部分。&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://datawhalechina.github.io/llm-universe/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;动手学大模型应用开发&lt;/a&gt; 面向小白开发者的大模型应用开发教程，基于阿里云服务器，结合个人知识库助手项目，通过一个课程完成大模型开发的重点入门。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ios-开发&#34;&gt;iOS 开发&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.udemy.com/course/ios-13-app-development-bootcamp/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;iOS &amp;amp; Swift - The Complete iOS App Development Bootcamp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.hackingwithswift.com/100/swiftui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;The 100 Days of SwiftUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cs193p.sites.stanford.edu/2023&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Stanford CS193p - Developing Apps for iOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.kodeco.com/ios/paths/learn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;iOS and SwiftUI for Beginners&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.coursera.org/professional-certificates/meta-ios-developer&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Meta iOS Developer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.apple.com/tutorials/develop-in-swift-tutorials&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Develop in Swift Tutorials&lt;/a&gt; 苹果官方教程&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.apple.com/tutorials/swiftui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SwiftUI Tutorials&lt;/a&gt; 苹果官方教程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计算机科学史&#34;&gt;计算机科学史&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/25752043/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;信息简史&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Helm 和 Helm chart Test 在 ARM 和 RISV-V 上的自动化测试</title>
        <link>https://mahaoliang.tech/p/helm-%E5%92%8C-helm-chart-test-%E5%9C%A8-arm-%E5%92%8C-risv-v-%E4%B8%8A%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</link>
        <pubDate>Sat, 29 Jun 2024 10:44:41 +0800</pubDate>
        
        <guid>https://mahaoliang.tech/p/helm-%E5%92%8C-helm-chart-test-%E5%9C%A8-arm-%E5%92%8C-risv-v-%E4%B8%8A%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</guid>
        <description>&lt;p&gt;本文是我参加&lt;a class=&#34;link&#34; href=&#34;https://opencamp.cn/EulixOS/camp/202401&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《第一期傲来操作系统（EulixOS）训练营》&lt;/a&gt;的项目实习报告。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://eulixos.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;傲来操作系统（EulixOS）&lt;/a&gt;是由中科院软件所 / 中科南京软件技术研究院团队基于 openEuler 打造的操作系统发行版。&lt;/p&gt;
&lt;h2 id=&#34;任务目标&#34;&gt;任务目标&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/helm/helm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Helm&lt;/a&gt; 是一个 &lt;code&gt;Kubernetes&lt;/code&gt; 的包管理工具，它可以帮助用户定义、安装和升级运行在 &lt;code&gt;Kubernetes&lt;/code&gt; 上的应用程序。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/helm/chart-testing&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Helm chart test&lt;/a&gt; 是一个用于测试 &lt;code&gt;Helm&lt;/code&gt; 图表的 CLI 工具，用于测试 &lt;code&gt;Helm chart&lt;/code&gt; 的拉取请求，能自动检测与目标分支相比已经更改的 chart。&lt;/p&gt;
&lt;p&gt;本任务计划在 ARM 和 RISC-V 架构上运行 &lt;code&gt;Helm&lt;/code&gt; 和 &lt;code&gt;Helm chart Test&lt;/code&gt; 的测试，以此来对比这两种平台上云原生软件的成熟度。&lt;/p&gt;
&lt;h2 id=&#34;helm-的单元测试&#34;&gt;Helm 的单元测试&lt;/h2&gt;
&lt;p&gt;分析 Helm 的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/helm/helm/blob/main/Makefile&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Makefile&lt;/a&gt; 文件，发现 &lt;code&gt;test-unit&lt;/code&gt; 目标是用来运行单元测试的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;.PHONY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;-&lt;span class=&#34;n&#34;&gt;unit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;test-unit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	@echo
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	@echo &lt;span class=&#34;s2&#34;&gt;&amp;#34;==&amp;gt; Running unit tests &amp;lt;==&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nv&#34;&gt;GO111MODULE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;on go &lt;span class=&#34;nb&#34;&gt;test&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;GOFLAGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -run &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;TESTS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;PKG&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;TESTFLAGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以看出，helm 的单元测试可以直接通过 &lt;code&gt;go test&lt;/code&gt; 命令来执行。&lt;/p&gt;
&lt;p&gt;查看 &lt;a class=&#34;link&#34; href=&#34;https://github.com/helm/helm/blob/main/go.mod&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go.mod&lt;/a&gt; 文件，确定该项目使用的 Go 版本是 1.22.0：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;module helm.sh/helm/v3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go 1.22.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;require (
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	github.com/BurntSushi/toml v1.3.2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;helm-chart-test-的单元测试&#34;&gt;Helm chart test 的单元测试&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Helm chart test&lt;/code&gt; 项目使用 &lt;a class=&#34;link&#34; href=&#34;https://github.com/helm/chart-testing/blob/main/build.sh&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;build.sh&lt;/a&gt; 脚本进行构建发布。分析 &lt;code&gt;build.sh&lt;/code&gt; 发现，在每次构建前，会使用 &lt;code&gt;go test -race ./...&lt;/code&gt; 运行单元测试：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go &lt;span class=&#34;nb&#34;&gt;test&lt;/span&gt; -race ./...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;goreleaser &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;goreleaser_args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[@]&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;查看&lt;a class=&#34;link&#34; href=&#34;https://github.com/helm/chart-testing/blob/main/go.mod&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go.mod&lt;/a&gt;文件，确定该项目使用的 Go 版本是 1.22.0：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;github&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;com&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;helm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.22&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;toolchain&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;go1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;22.4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;自动化执行测试&#34;&gt;自动化执行测试&lt;/h2&gt;
&lt;p&gt;helm 和 helm chart test 的单元测试都可以直接通过 &lt;code&gt;go test&lt;/code&gt; 命令来执行。我们可以使用 bash 编写脚本使测试过程自动化。&lt;/p&gt;
&lt;p&gt;这个脚本的主要流程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动识别和配置：脚本首先检测硬件平台，然后自动下载并在测试目录下安装 Go，不干扰系统中的其他设置或版本。&lt;/li&gt;
&lt;li&gt;环境设置：配置必要的环境变量，确保测试在适当的环境下执行。&lt;/li&gt;
&lt;li&gt;代码仓库管理：自动从配置的 Git 仓库地址克隆代码到本地指定目录。&lt;/li&gt;
&lt;li&gt;测试执行：运行单元测试，并将结果输出到报告文件中。&lt;/li&gt;
&lt;li&gt;性能数据收集：通过调用 &lt;code&gt;performance_counter_920.sh&lt;/code&gt; 收集和记录测试期间的性能指标。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了避免网络环境对测试影响，脚本可以自定义配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;GO_BASE_URL&lt;/code&gt; 定义 go 安装包下载网址&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;REPO_URL&lt;/code&gt; 定义项目源码仓库的地址。可以提前将项目从 GitHub 同步到 Gitee。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;GOPROXY&lt;/code&gt; 定义 Go 镜像地址。缺省设置为 &lt;code&gt;GOPROXY=https://goproxy.cn&lt;/code&gt;，从国内镜像下载 moudle。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，helm 在测试插件功能时，会访问 &lt;a class=&#34;link&#34; href=&#34;https://github.com/adamreese/helm-env&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/adamreese/helm-env&lt;/a&gt; 。由于网络环境问题，涉及的测试经常会失败。所以我将 helm-env 项目同步到了 gitee，并修改了测试案例 &lt;a class=&#34;link&#34; href=&#34;https://gitee.com/mahaoliang/helm/blob/02417b31ab70be386bb0a18045cbbca8dd9b8a8b/pkg/plugin/installer/vcs_installer_test.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;vcs_installer_test.go&lt;/a&gt;，让它从 gitee 下载插件，保证了测试运行的稳定。&lt;/p&gt;
&lt;p&gt;两个项目的自动化测试脚本都已经提交到了 gitee，分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gitee.com/mahaoliang/helm-test&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gitee.com/mahaoliang/helm-test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gitee.com/mahaoliang/helm-chart-test&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://gitee.com/mahaoliang/helm-chart-test&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;测试结果&#34;&gt;测试结果&lt;/h2&gt;
&lt;p&gt;下面是在 ARM 上运行的 helm 的测试结果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; duration time: &lt;span class=&#34;m&#34;&gt;24558698523&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; task clock: 130738.640
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; cpu-cycles:   &lt;span class=&#34;m&#34;&gt;290310169669&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; instructions: &lt;span class=&#34;m&#34;&gt;269526073395&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; cache references: &lt;span class=&#34;m&#34;&gt;95029267023&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; cache misses: &lt;span class=&#34;m&#34;&gt;764800123&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; branches: &amp;lt;not
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; branch misses: &lt;span class=&#34;m&#34;&gt;647318994&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; L1 dcache loads: &lt;span class=&#34;m&#34;&gt;95029267023&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; L1 dcache load misses: &lt;span class=&#34;m&#34;&gt;764800123&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; LLC load misses: &lt;span class=&#34;m&#34;&gt;480961351&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; LLC load: &lt;span class=&#34;m&#34;&gt;1156309818&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; IPC: 0.928
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helmrequiresearchfil.txt has been deleted
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Number of packages: &lt;span class=&#34;m&#34;&gt;50&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Analyzing &lt;span class=&#34;nb&#34;&gt;test&lt;/span&gt; results in /home/cloud2/helm-test/reports/20240628135442/test_result
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Total tests: &lt;span class=&#34;m&#34;&gt;1327&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Passed tests: &lt;span class=&#34;m&#34;&gt;1327&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Failed tests: &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;一共运行了 1327 个测试用例，全部通过。&lt;/p&gt;
&lt;p&gt;在 ARM 上运行的 helm chart test 的测试结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; duration time: &lt;span class=&#34;m&#34;&gt;704309016&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; task clock: 5337.880
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; cpu-cycles:   &lt;span class=&#34;m&#34;&gt;10071410187&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; instructions: &lt;span class=&#34;m&#34;&gt;8342502186&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; cache references: &lt;span class=&#34;m&#34;&gt;3300195194&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; cache misses: &lt;span class=&#34;m&#34;&gt;34476953&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; branches: &amp;lt;not
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; branch misses: &lt;span class=&#34;m&#34;&gt;39065962&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; L1 dcache loads: &lt;span class=&#34;m&#34;&gt;3300195194&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; L1 dcache load misses: &lt;span class=&#34;m&#34;&gt;34476953&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; LLC load misses: &lt;span class=&#34;m&#34;&gt;15971288&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; LLC load: &lt;span class=&#34;m&#34;&gt;50427439&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Avg &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;times&lt;/span&gt; IPC: 0.828
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Number of packages: &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Analyzing &lt;span class=&#34;nb&#34;&gt;test&lt;/span&gt; results in /home/cloud2/helm-chart-test/reports/20240628140012/test_result
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Total tests: &lt;span class=&#34;m&#34;&gt;92&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Passed tests: &lt;span class=&#34;m&#34;&gt;92&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Failed tests: &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;一共运行了 92 个测试用例，全部通过。&lt;/p&gt;
&lt;p&gt;测试过程详细输出的原始文件如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cdn.mahaoliang.tech/2024/202507261057451&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;helm 的 go test 输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cdn.mahaoliang.tech/2024/202507261058094&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;helm 测试过程的 perf 统计指标&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cdn.mahaoliang.tech/2024/202507261058288&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;helm chart test 的 go test 输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://cdn.mahaoliang.tech/2024/202507261059355&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;helm chart test 测试过程的 perf 统计指标&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到测试截止时间，RISC-V 机器还未准备好，因此没有运行 RISC-V 架构的测试。不过我们已经提供了自动化测试脚本，可以直接在 RISC-V 架构的机器上运行，为后面在 RISC-V 上的测试做好了准备。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
